---
title: 学习笔记 - KMP
date: 2024-01-20 21:37:12 +0800
categories: [学习笔记]
tags: [kmp]
math: true
---

**KMP** 是一种高效的字符串模式匹配算法。

## Border 的概念

如果一个字符串 $s$ 的开头 $t$ 个字符构成的子串和末尾 $t$ 个字符构成的子串完全相同，且 $t$ 小于 $s$ 本身的长度（记作 $t<\lvert s \rvert$），我们就把这个长度为 $t$ 的子串叫做 $s$ 的一个 **Border**。例如：

- $\texttt{aba}$ 的唯一一个 Border 是 $\texttt{a}$；
- $\texttt{abbcbba}$ 的唯一一个 Border 是 $\texttt{a}$（注意“首尾子串相同“和回文串的区别）；
- $\texttt{acbbaacb}$ 的唯一一个 Border 是 $\texttt{acb}$；
- $\texttt{ababa}$ 有两个 Border，分别是 $\texttt{a}$ 和 $\texttt{aba}$；
- $\texttt{abcdcb}$ 没有 Border。

### 关于 Border 的一些性质

**性质 1**：如果字符串 $a$ 是 $b$ 的 Border，$b$ 是 $c$ 的 Border，那么 $a$ 也是 $c$ 的 Border。简记为“Border 的 Border 也是 Border”。

**证明**：因为 $b$ 是 $c$ 的 Border，所以 $b$ 会在 $c$ 的首尾各出现一次；因为 $a$ 是 $b$ 的 Border，所以 $a$ 也一定会在 $c$ 开头处 $b$ 的开头、$c$ 末尾处 $b$ 的末尾出现，也即 $a$ 是 $c$ 的 Border。~~（这么显然的结论似乎也没必要给出严格的证明吧...）~~

```plaintext
a: aa
b: aabbbaa
c: aabbbaacccccccaabbbaa
b:               aabbbaa
a:                    aa
```

**性质 2**：如果字符串 $a$ 和 $b$ 都是 $c$ 的 Border，且 $\lvert a \rvert < \lvert b \rvert$（$\lvert s \rvert$ 表示字符串 $s$ 的长度），那么 $a$ 也是 $b$ 的 Border。简记为“小 Border 是大 Border 的 Border”。

**证明**：$a,b$ 都在 $c$ 的首尾同时出现，那么 $a$ 和 $b$ 必然有包含关系。由 $\lvert a \rvert < \lvert b \rvert$ 可知 $a$ 一定出现于 $b$ 的内部，且在 $c$ 开头处 $b$ 的开头、$c$ 末尾处 $b$ 的末尾各出现一次，即 $a$ 是 $b$ 的 Border。

```plaintext
a: aa                  a:             aa
b: aabbb           =>  b:          aabaa
c: aabbbccccbbbaa      c: aabaaccccaabaa
```

**性质 3**：记 $s$ 的最长 Border 长度为 $\operatorname{mxb}(s)$，用 $\operatorname{pre}(s,x)$ 表示”$s$ 的前 $x$ 个字符组成的子串“，那么 $s$ 的所有 Border 都可以表示为 $\operatorname{pre}(s,\operatorname{mxb}(s)),\operatorname{pre}(s,\operatorname{mxb}(\operatorname{pre}(s,\operatorname{mxb}(s)))), \dots$。换句话说，$s$ 的 Border、$s$ 的 Border 的 Border、……全部都是 $s$ 的 Border。

利用性质 1 进行归纳即可证明。

## 字符串模式匹配

我们主要研究这个问题：给出两个字符串 $s$ 和 $t$，求 $t$ 在 $s$ 中出现的位置有哪些。考虑暴力做法：尝试把 $s$ 的每个位置都当作出现位置，然后依次往后和 $t$ 比较进行验证。

```c++
int n, m;
char s[MAXN], t[MAXN];

n = strlen(s + 1);
m = strlen(t + 1);
for (int k = 1; k <= n - m + 1; k++)
{
    bool flag = true;
    for (int i = k, j = 1; j <= m; i++, j++)
    {
        if (s[i] != t[j])
        {
            flag = false;
            break;
        }
    }
    if (flag)
        printf("%d\n", i);
}
```

不难发现这个算法是 $O(nm)$ 的。这个算法看起来会很“笨”，比如下面这种情况：

```plaintext
    k=2
    |    i=7
    v    v
s: cabababacbab
t:  ababacb
         ^
         j=6
```

很明显在 $i=7,j=6$ 时匹配失败了，这时候我们的程序选择令 $i=3$，然后再让 $j=1$ 从头开始重新比较：

```plaintext
     k=i=3
     v
s: cabababacbab
t:   ababacb
     ^
     j=1
```

如果换作一个人来模拟上述过程，那他绝对不会再让 $j$ 从头来过，因为很明显有一段 $\texttt{ababa}$ 是已经匹配好了的。我们可以直接把 $i$ 前进一格，$j$ 往后退一格（相当于把 $t$ 串这个整体向右移动 $2$ 格）就能让这一段对上：

```plaintext
          i=8
          v
s: cabababacbab
t:    ababacb
          ^
          j=5
```

仔细思考一下，为什么可以这么做？因为 $\operatorname{pre}(t,5)$ 中有一个 Border $\texttt{aba}$，它在我们刚刚匹配掉的 $s$ 中 $\texttt{ababa}$ 这个子串中首尾各出现了一次，于是我们可以通过适当的移动来让 $s$ 末尾的 Border 和 $t$ 开头的 Border 对齐，这样就能提高匹配效率了。

## 进与退的艺术

假设我们手里有两个指针 $i,j$，分别指向 $s,t$ 中的某个位置。$i$ 是冲在前方的老大，只前进不后退；$j$ 是 $i$ 的小跟班，它的位置和进退完全由 $i$ 决定。我们规定，$i$ 和 $j$ 走过的足迹必须相同，即在匹配过程中，**始终要满足** $t[1,j]=s[i-j+1,i]$（用 $s[l,r]$ 表示字符串 $s$ 从第 $l$ 个字符到第 $r$ 个字符组成的子串），或者 $j=0$。这样当 $j=m$ 时，我们就找到了一个匹配。

前进之前，$i$ 和 $j$ 各自往前看一眼，如果它们前面的字符都相同，即 $s_i=t_j$，那么它们就可以愉快地一起行走，即 $i \gets i+1, j \gets j+1$。

```plaintext
       i=5                               i=6
       v                                 v
s: cabababacbab    s[6]==t[5]    s: cabababacbab
t:  ababacb      ------------->  t:  ababacb
       ^                                 ^
       j=4                               j=5
```

那如果不同呢？因为 $i$ 是老大，他无论如何都要往前走一格（即 $i \gets i+1$），这时 $j$ 就要调整他的位置，使得他俩的足迹要一致。

```plaintext
         i=7
         v
s: cabababacbab
t:  ababacb

    j=??? <= j=5
```

显然 $j$ 不想离老大落后太远，所以它后退的距离越小越好。假设我们知道现在的 $t[1,j]$ 有一个长度为 $h$ 的 Border，且这个 Border 是 $t[1,j]$ 的所有 Border 中最长的，那么我们可以先试着把这个 Border 挪过来，然后看看这时候 $j$ 还能不能追上 $i$ 的足迹，即检查 $t_{h+1}=s_i$ 是否成立。**（注意，此时 $i$ 已经往前走了一格）**

```plaintext
       t: ababacb
pre(t,5): ababa
          aba    => h=3
            aba

            i=7
            v
s: cab[aba][b]acbab
t:    [aba][b]acb
            ^ ^
            | j=5
            h+1=4
```

如果成立的话当然皆大欢喜，只需要让 $j$ 退后到 $j \gets h+1$ 就好了。

```plaintext
         i=7
         v
s: cabababacbab
t:    ababacb
         ^
         j=4
```

但万一不成立呢？比如我们把 $s_7$ 修改成 $\texttt{a}$：

```plaintext
            i=7
            v
s: cab[aba][a]acbab
t:    [aba][b]acb
            ^ ^
            | j=5
            h+1=4
```

显然 $h=3$ 的这个 Border 不行了，我们要尝试其他的 Border。如何知道其他 Border 的长度呢？根据 Border 的性质 3，我们只要看这个大 Border 的小 Border 就行了。发现 $\texttt{aba}$ 还有一个 Border $\texttt{a}$，长度 $h=1$，我们试着把它也挪过来：

```plaintext
            i=7
            v
s: cabab[a][a]acbab
t:      [a][b]abacb
            ^   ^
            |   j=5
            h+1=2
```

依然不行，但是 $\texttt{a}$ 已经没有更小的 Border 了，没有办法，只好让 $j=0$，从头开始重新比较：

```plaintext
         i=7
         v
s: cababaaacbab
t:        ababacb
         ^
         j=0
```

以上就是 KMP 算法的大致流程。我们可以简单归纳如下：

```plaintext
int brd[MAXN]; // 定义brd[i]为pre(t,i)的最长Border长度
int j = 0;
for(int i = 1; i <= n; i++)
{
    i已经先走一步；
    尝试让j后退到合适的位置，定义h为目前考虑的Border长度，初始时h=brd[j]
    {
        如果t[h+1]==s[i]，那么j=h，结束；
        否则寻找更小的Border，即h=brd[h]；
        如果h=0说明没有合适的退回位置，令j=0，从头开始匹配。
    }
    如果t[j+1]==s[i]，那么j++；
    如果j==m，说明找到了一次匹配，保存结果，顺便提前让j后退到最大Border的开头处对齐。
}
```

一种比较简洁的实现如下，这里省去了 $h$ 作为中间变量：

```c++
int j = 0;
for (int i = 1; i <= n; i++)
{
    while (j != 0 && t[j + 1] != s[i])
        j = brd[j];
    if (t[j + 1] == s[i])
        j++;
    if (j == m)
        printf("%d\n", i - j + 1), j = brd[j];
}
```

## 最后的问题

**$brd$ 数组应该怎么求呢？** 其实很简单，本质上也是一个不断从大到小找 Border 的过程。

假设我们已经知道了对于 $x \in [1,i-1]$ 的所有 $brd_x$ 的值，想要求出 $brd_{i}$。先看前一个位置的 Border $brd_{i-1}$，如果 $t_i$ 这个字符刚好可以和前面的这个 Border 拼上，那么我们就拼到了一个更大的 Border $brd_i \gets brd_{i-1}+1$。

| $i$   | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| $t$   | a   | b   | a   | b   | a   | b   | c   |
| $brd$ | 0   | 0   | 1   | ?   |     |     |     |

```plaintext
i=4, b=brd[i-1]
    b=1                        b+1=2
    v      t[1+1]==t[3=1]    v
    aba   --------------->  abab  -----> brd[4]=2
      ^                        ^
      i-b+1=3                  i-b=4
```

如果拼不上呢？那就找更小的 Border，即 `brd[brd[i-1]]`，直到找到能拼上的为止；或者找不到能拼上的，说明这个子串没有 Border，令 $brd_i \gets 0$。

| $i$   | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| $t$   | a   | b   | a   | b   | a   | b   | c   |
| $brd$ | 0   | 0   | 1   | 2   | 3   | 0   | 0   |

代码实现和 KMP 主算法其实差不多：

```c++
brd[1] = 0;
for (int i = 2; i <= m; i++)
{
    int h = brd[i - 1]; // h是目前考虑的Border
    while (h != 0 && t[h + 1] != t[i]) // 不断找更小的Border，直到能拼上或者不存在
        h = brd[h];
    if (t[h + 1] == t[i]) // 如果找到了能拼上的就可以拼成更大的Border
        brd[i] = h + 1;
}
```

### 例题

裸的 KMP 已经几乎不会考了，大部分时候会结合更高级的知识点进行应用（例如下面要讲的失配树，以及 AC 自动机等）。

- 【模板】KMP - [洛谷](https://www.luogu.com.cn/problem/P3375)

## 失配树

显然对于任意 $i \in [1,n]$，都有 $brd_i < i$。如果我们建一颗树，使得 $brd_i$ 是 $i$ 的父亲，那么我们就得到了这个字符串的失配树。比如 $\texttt{abcabcba}, brd=0, 0, 0, 1, 2, 3, 0, 1$ 的失配树就长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/uv6n9x21.png)

我们一般认为失配树的根是 $0$ 号节点。那么这个失配树有什么具体含义呢？根据前面提到的性质 1，Border 的 Border 也是 Border。也就是说，对于失配树的某个节点，它到根 $0$ 的路径上的所有节点都是它自己的 Border 长度。假如我们想要求某个前缀字符串 $\operatorname{pre}(s,i)$ 有多少个 Border，那我们只要求点 $i$ 在失配树上的深度就好了。求深度可以直接在计算 $brd$ 数组时顺便完成：

```c++
brd[1] = 0;
dep[0] = 0;
dep[1] = 1; // 记得初始化
for (int i = 2; i <= n; i++)
{
    int h = brd[i - 1];
    while (h != 0 && str[h + 1] != str[i])
        h = brd[h];
    if (str[h + 1] == str[i])
        brd[i] = h + 1;
    dep[i] = dep[brd[i]] + 1;   // 加这句话就够了
}
```

失配树既然是树，那就可以在它上面求 LCA、倍增、DP……总之有关有根树的一切操作都可以在这上面应用。

### 例题

- 【模板】失配树 - [洛谷](https://www.luogu.com.cn/problem/P5829)
- 「POI2006」 OKR-Periods of Words - [洛谷](https://www.luogu.com.cn/problem/P3435) / [LOJ](https://loj.ac/p/10046)
- 「POI2005」 SZA-Template - [洛谷](https://www.luogu.com.cn/problem/P3426)
- 「NOI2014」 动物园 - [洛谷](https://www.luogu.com.cn/problem/P2375) / [LOJ](https://loj.ac/p/2246) / [UOJ](https://uoj.ac/problem/5) ~~（注意不是 「CSP-S 2020」 动物园）~~
