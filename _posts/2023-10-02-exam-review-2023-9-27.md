---
title: 考试总结 - 2023.9.27
date: 2023-10-02 17:17:50 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## `light` - 光

**解法千万条，暴力第一条。剪枝不对拍，爆零两行泪。**

属于是[不长记性]({{ "/posts/exam-review-noip-2021-simulated" | relative_url }})。考试结束前几分钟想到的一个剪枝策略直接加了上去，没有对拍，用给的样例试了一遍都能过，然后就非常自信的交了，于是喜提 -50。

### Subtask 1：暴力（70%）

直接 $O(n^3)$ 枚举前三盏灯的电量，可以据此计算出第四盏灯的最低电量，维护电量之和的最小值即可。

有个需要注意的问题：每盏灯枚举的电量上界是多少？如果最高只到亮度限制，很容易举出一个反例：`2 3 1 2`（答案是 $4$，在右上角放一盏电量为 $4$ 的灯，如果电量只枚举到亮度限制的话得到的答案是 $5$）。保险一点的做法是把上界设成比亮度限制略大的值。

```c++
int r[5];   // 最低亮度
int l[5];   // 电量
int w[5];   // 实际亮度
int ans = INF;

void dfs(int step)
{
    if (step == 4)
    {
        w[1] = l[1] + l[2] / 2 + l[3] / 2;
        w[2] = l[1] / 2 + l[2] + l[3] / 4;
        w[3] = l[1] / 2 + l[2] / 4 + l[3];
        w[4] = l[1] / 4 + l[2] / 2 + l[3] / 2;
        int sum = l[1] + l[2] + l[3];
        int d1 = max(0, r[1] - w[1]) * 4;
        int d2 = max(0, r[2] - w[2]) * 2;
        int d3 = max(0, r[3] - w[3]) * 2;
        int d4 = max(0, r[4] - w[4]);
        l[4] = max(max(d1, d2), max(d3, d4));
        sum += l[4];
        ans = min(ans, sum);
        return;
    }
    for (int i = 0; i <= r[step] + 4; i++)  // 不+4会很容易出问题
    {
        l[step] = i;
        dfs(step + 1);
    }
}
```

### Subtask 2：AC（100%）

显然，能用的总电量越多，实现最低亮度的难度就越低，也就是说答案的可行性存在单调性，考虑二分答案。假设固定 $lim$ 点电量分配给四盏灯，检验能否满足亮度需求。

## `crawl` - 爬

### Subtask 1：$n \leq 20$（10%）

二进制枚举状态（每只蚂蚁爬/不爬），把快乐值全部算出来相加。

### Subtask 2：链状图（+10%）

手玩一下可以发现规律：相邻的两只蚂蚁配对，最靠近根的那一对可以对答案产生 $2^{n-2}$ 次贡献，剩下的可以产生 $2^{n-3}$ 次贡献。

### Subtask 3：AC（100%）

## `string` - 字符串

### Subtask 1：暴力枚举（20%）

枚举 $n$ 个 $\texttt{A}$ 和 $m$ 个 $\texttt{B}$ 的排列，把权值算出来。

### Subtask 2：暴力 DP（50%）

定义 $dp(x,c,a,b)$ 为已经放了 $a$ 个 $\texttt{A}$、$b$ 个 $\texttt{B}$、以字母 $x$ 结尾且这个字母在末尾已经连续出现了 $c$ 次的最大权值。$O(n^3)$ 枚举 $a,b,c$ 进行转移。

```c++
int dp[2][103][103][103];
inline void solve2()
{
    for (int i = 0; i <= max(m, n); i++)
    {
        for (int j = 0; j <= n; j++)
        {
            for (int k = 0; k <= m; k++)
            {
                dp[0][i][j][k] = dp[1][i][j][k] = -INF;
            }
        }
    }
    dp[0][1][1][0] = 1;
    dp[1][1][0][1] = 1;
    for (int p = 0; p <= n; p++)
    {
        for (int q = 0; q <= m; q++)
        {
            if ((p == 1 && q == 0) || (p == 0 && q == 1))
                continue;
            if (p >= 1)
            {
                for (int k = c; k <= q; k++)
                {
                    dp[0][1][p][q] = max(dp[0][1][p][q], dp[1][k][p - 1][q] + 1);
                }

                for (int k = 2; k <= p; k++)
                {
                    dp[0][k][p][q] = max(dp[0][k][p][q], dp[0][k - 1][p - 1][q] + ((k - 1) % a == 0 ? 1 : 0));
                }
            }
            if (q >= 1)
            {
                for (int k = 1; k <= p; k++)
                {
                    dp[1][1][p][q] = max(dp[1][1][p][q], dp[0][k][p][q - 1] + 1);
                }
                for (int k = 2; k <= q; k++)
                {
                    dp[1][k][p][q] = max(dp[1][k][p][q], dp[1][k - 1][p][q - 1] + ((k - 1) % b == 0 ? 1 : 0));
                }
            }
        }
    }

    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans = max(ans, dp[0][i][n][m]);
    for (int i = 1; i <= m; i++)
        ans = max(ans, dp[1][i][n][m]);
    printf("%d\n", ans);
}
```

### Subtask 3：AC（100%）

其实是一道伪装成 DP 的贪心题。显然，靠堆区间长度来获取价值不如频繁在 $\texttt{A}$、$\texttt{B}$ 之间切换获取价值来得快，因此如果没有 $c$ 的限制的话，最优解就会形如 $\texttt{ABABAB...}$ 再把剩下的 $\texttt{A}$ 或 $\texttt{B}$ 用完。

考虑了 $c$ 的限制该怎么办？那就让所有 $\texttt{B}$ 字符的区间长度都尽量恰好为 $c$，例如当 $c=3$ 时，得到的字符串为 $\texttt{...BBBABBBABBBA...}$（称为中心串）。中心串是 $\texttt{BBB}$ 和 $\texttt{A}$ 的反复切换，如此一来只需要考虑剩下的 $\texttt{A}$ 和 $\texttt{B}$ 怎么处理就好了。可以枚举切换的次数以及开头和结尾的串类型，再计算出剩余字母的贡献：

- 对于剩下的 $\texttt{A}$，如果中心串以 $\texttt{B}$ 开头，首先可以在开头放一个，价值 $+1$；
- 如果剩下的 $\texttt{A}$ 多于 $1$ 个，那就把它们堆积在循环节中间，根据规则 1，每 $a$ 个 $\texttt{A}$ 可以对价值产生 $+1$ 贡献；
- 对于剩下的 $\texttt{B}$，如果中心串以 $\texttt{A}$ 结尾，首先可以在末尾放一个，价值 $+1$；
- 如果剩下的 $\texttt{B}$ 多于 $1$ 个，同样考虑把它们堆积在循环节中间，此时每 $c-b+1$ 个 $\texttt{B}$ 可以对价值产生 $+1$ 贡献。但是这些贡献是有次数限制的，即 $\texttt{B}$ 串的出现次数；如果这些次数用完了，那可以接在最后一个 $\texttt{B}$ 后面，每 $b$ 个 $\texttt{B}$ 对价值产生 $+1$ 贡献。

## `func` - 奇怪的函数

### Subtask 1：暴力模拟（5%）

题目怎么说就怎么做。

### Subtask 2：只处理查询（30%）

把所有的操作合并，$F(x)$ 函数就会浓缩成一个简单的三段分段函数：小于或大于某个阈值时结果为两个常数，中间一段是斜率为 $1$ 的一次函数。计算出这两个阈值就可以直接回答所有询问了。找阈值可以直接数学计算，也可以二分。

```c++
inline void solve2()
{
    ll sum = 0;
    for (int i = 1; i <= n; i++)
        sum += ops[i].val;
    ll ca, cb;
    ll l = -sum, r = sum, mid = (l + r) >> 1, ans = 0;
    ll peak1 = runF(l);
    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (runF(mid) <= peak1)
        {
            ans = mid;
            l = mid + 1;
        }
        else
        {
            r = mid - 1;
        }
    }
    ca = ans;
    l = -sum, r = sum, mid = (l + r) >> 1, ans = 0;
    ll peak2 = runF(r);
    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (runF(mid) >= peak2)
        {
            ans = mid;
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    cb = ans;

    for (int i = 1; i <= q; i++)
    {
        ll x = qrs[i].val;
        if (x <= ca)
            printf("%lld\n", peak1);
        else if (x >= cb)
            printf("%lld\n", peak2);
        else
            printf("%lld\n", x - ca + peak1);
    }
}
```

### Subtask 3：维护区间和（55%）

由于操作总数是不会变的，可以把整个函数流程映射为一个长度为 $n$ 的数组，相应位置如果是加法操作那么值就是 $val$，如果是取最值就是 $0$。维护这个数组的区间和，同时维护一个 `set` 用来存储所有取最值操作的位置。求答案时本质还是模拟，但是只枚举一遍 `set` 单独处理所有取最值操作，剩下的求和部分可以利用维护好的区间和进行加速。

维护区间和用树状数组最简单 ~~（如果硬要用线段树也不是不可以）~~。复杂度与取最值操作的数量有关。

```c++
// fwAdd(pos,val) 和 fwGet(pos) 是树状数组板子，具体实现略
set<int> keys; // 所有取最值操作的位置
inline ll runF_fwFast(ll x)
{
    int lst = 0;
    for (int k : keys)
    {
        x += fwGet(k - 1) - fwGet(lst); // 区间和加速
        lst = k;
        // 取最值单独处理
        if (ops[k].type == 2)
            x = min(x, (ll)ops[k].val);
        if (ops[k].type == 3)
            x = max(x, (ll)ops[k].val);
    }
    x += fwGet(n) - fwGet(lst); // 别忘了加上最后一段
    return x;
}
inline void solve3()
{
    for (int i = 1; i <= n; i++)
    {
        if (ops[i].type == 1)
            fwAdd(i, ops[i].val);
        if (ops[i].type == 2 || ops[i].type == 3)
            keys.insert(i);
    }
    for (int i = 1; i <= q; i++)
    {
        switch (qrs[i].type)
        {
        case 1:
            // 修改为相加
            // 如果这个位置原来就是相加操作，需要减去原来的数
            if (ops[qrs[i].pos].type == 1)
                fwAdd(qrs[i].pos, -ops[qrs[i].pos].val);
            // 维护keys
            if (ops[qrs[i].pos].type != 1)
                keys.erase(qrs[i].pos);
            fwAdd(qrs[i].pos, qrs[i].val);
            break;
        case 2:
            // 修改为取最值（2是min，3是max）
            // 如果这个位置原来是相加操作，需要把加数删除，同时keys里新增一个标记
            if (ops[qrs[i].pos].type == 1)
            {
                keys.insert(qrs[i].pos);
                fwAdd(qrs[i].pos, -ops[qrs[i].pos].val);
            }
            break;
        case 3:
            // 同case 2
            if (ops[qrs[i].pos].type == 1)
            {
                keys.insert(qrs[i].pos);
                fwAdd(qrs[i].pos, -ops[qrs[i].pos].val);
            }
            break;
        case 4:
            // 查询
            printf("%lld\n", runF_fwFast(qrs[i].val));
            break;
        }
        // 修改原始操作序列
        if (qrs[i].type <= 3)
        {
            ops[qrs[i].pos].type = qrs[i].type;
            ops[qrs[i].pos].val = qrs[i].val;
        }
    }
}
```

### Subtask 3：AC（100%）
