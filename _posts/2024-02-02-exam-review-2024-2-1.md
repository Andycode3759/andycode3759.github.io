---
title: 考试总结 - 2024.2.1
date: 2024-02-02 16:53:28 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## $T_1$

考试时在不知道的情况下手推出了欧拉函数的计算式，但止步于如何出答案（

\_LittleBoat\_ 提出了一种不用卷积、直接容斥的做法。我们先处理出对于每个 $x$ 有多少个数的欧拉函数值等于 $x$，记为 $cnt_x$，然后枚举 $\phi(i)$ 和 $\phi(j)$ 的 GCD，记为 $g$，这样所有 $g$ 的倍数都可以组合出 $g$ 这个公因数。但是它们的最大公因数可能不是 $g$ 而是 $g$ 的另一个倍数 $k$，我们需要把这些组合方案减去。最后用所有的组合方案数乘对应的 $\phi(g)$ 累加即可求出答案。

```c++
using ll = long long;
const int MAXN = 10000007;

vector<int> prime;
int phi[MAXN], cnt[MAXN];
bitset<MAXN> np;
ll cont[MAXN];  // cont[x]=有多少对(i,j)可以组合出gcd(phi[i],phi[j])==x

int main()
{
    freopen("phi.in", "r", stdin);
    freopen("phi.out", "w", stdout);

    // 标准线性筛
    np[1] = true;
    phi[1] = 1;
    for (int i = 2; i < MAXN; ++i)
    {
        if (!np[i])
        {
            phi[i] = i - 1;
            prime.push_back(i);
        }
        for (int p : prime)
        {
            int j = i * p;
            if (j >= MAXN)
                break;
            np[j] = true;
            if (i % p == 0)
            {
                phi[j] = phi[i] * p;
                break;
            }
            phi[j] = phi[i] * phi[p];
        }
    }

    int n;
    scanf("%d", &n);
    ll ans = 0;
    for (int i = 1; i <= n; ++i)
        ++cnt[phi[i]];

    for (int g = n; g >= 1; --g) // g是phi[i]和phi[j]的gcd
    {
        ll tmp = 0;
        for (int k = g; k <= n; k += g) // 枚举g的所有倍数k
        {
            tmp += cont[k];    // 组出来的gcd不是g而是k，这些方案需要减掉
                               // (当k=g时cont[k]=0)
            cont[g] += cnt[k]; // 带有因子g的数可以自由组合
        }
        cont[g] = cont[g] * cont[g] - tmp;
        ans += cont[g] * phi[g];
    }
    printf("%lld\n", ans);
    return 0;
}
```

遗憾的是这种优秀做法惨遭卡时限，被卡了 20 分（奇怪的是本机开 `O2` 测试是在 2s 内出结果的，评测机配置比学生机还更好）。

UPD: 因为 `cont` 和 `cnt` 这两个数组会被频繁来回访问，而两者的内存跨度又很大（$10^7$ 量级），导致代码内层循环有着比较大的时间常数。可以把两个数组的内存空间开到一起，就能让内存跨度减小、提高 Cache 命中率从而卡过本题。

```c++
ll cc[MAXN][2];
// cc[i][0] => cnt[i]
// cc[i][1] => cont[i]
```

## $T_2$

大搜索毒瘤题。

$n \leq 3$ 时直接分类讨论，把所有的图的形态都列出来再把答案相加：

```c++
int tot = quickPow(2, d) - 1;
if (n == 1)
    /* (x,y)
         i
    */
    printf("%d\n", quickPow(tot, 2));
else if (n == 2)
{
    /*
        (x,y) // x==y
        i->m
    */
    int ans1 = tot;
    /*
        (x,y) // x>=2,y>=2
        i->c
    */
    int ans2 = quickPow(tot - 1, 2);
    printf("%d\n", (ans1 + ans2) % MOD);
}
else if (n == 3)
{
    int ans[8];
    /* (x,a) (a,y)
        i1   i2    i1 i2
         \   /   +   x
           m         m
    */
    ans[1] = quickPow(tot, 3) * 2 % MOD;
    /*
      (x,y) // x>=4,y>=4
        i->c->c
    */
    ans[2] = n > 2 ? quickPow(tot - 3, 2) : 0;
    /*
        i->c->m
        |-----^
        x>=2,y>=2,y==x/2
        => x=2y or x=2y+1
    */
    ans[3] = (tot - 3) * 2 % MOD;
    /*
        i->c=>m
        x>=2,y>=2,x/2==y/2
    */
    ans[4] = quickPow(2, d + 1) - 4;
    /*
        i=>m->c
        x==y >= 2
    */
    ans[5] = tot - 1;
    /*
        i=>m=>m
        x==y
    */
    ans[6] = tot;
    /*
        i=>m->m
        |-----^
        x==y
    */
    ans[7] = tot * 2 % MOD;
    int ansTot = 0;
    for (int i = 1; i <= 7; i++)
        ansTot = (ansTot + ans[i]) % MOD;
    printf("%d\n", ansTot);
}
```

这 20 分不是很难拿，只需要有耐心即可。

## $T_3$

首先分析一下在树上遍历完所有点意味着什么。假设规定必须在遍历完最后一个点后回到起点，那么总路程就是总边权之和的两倍，因为去到一个点后还要回溯到父节点，即一条边会走两次。

那如果不需要回到起点呢？其实就相当于省去了从终点回到起点的这一条路径。题目要求总路程最小，其实就相当于求树上最长的一条路径。

首先在不知道怎么用 LCT 的情况下来打暴力。在线求答案可以做到 $O(n)$，模仿求树的直径的方法：随便选一个点作根，一遍 DFS 求出所有点到根的距离；再选距离最大的点做根，再来一遍 DFS 就可以求出最长路径。

这样做拿到 $q=0$ 的 20 分已经足够了，唯一剩下的难题就是怎么在处理询问时从树上删边。因为删边时是按点来索引边的，所以在没有数据结构的情况下删边显得有点困难。一种暴力的做法是直接从存图的 `vector` 里面删去对应点：

```c++
while (q--)
{
    int x, y, p, q, w;
    scanf("%d %d %d %d %d", &x, &y, &p, &q, &w);
    for (int i = 1; i < G[x].size(); i++)   // 把要删的点转移到最后一个位置，然后pop_back即可
    {
        if (G[x][i - 1].first == y)
            swap(G[x][i], G[x][i - 1]);
    }
    totLen -= G[x].back().second;
    G[x].pop_back();
    for (int i = 1; i < G[y].size(); i++)
    {
        if (G[y][i - 1].first == x)
            swap(G[y][i], G[y][i - 1]);
    }
    G[y].pop_back();
    totLen += w;
    G[p].push_back({q, w});
    G[q].push_back({p, w});
    solve();
}
```

因为 `vector` 内部数据是连续的，所以删点本身就需要 $O(n)$。之前口胡说这个做法是 $O(n^2q)$ 的，其实不对，因为删点和求答案是并列进行的，总复杂度还是 $O(nq)$，直接拿下 60 分。

这就让我写的哈希一点优势都没有了... 还因为没有处理冲突挂了 $q=0$ 的 20 分（

具体来讲，一条边可以被其两个端点唯一确定，所以可以设计一个神奇的哈希函数把一对点映射到一个整数：

```c++
const int MOD = 4999999;
mt19937_64 rng(time(0));
ll hashsd[MAXN];
inline int edgeHash(int x, int y)
{
    return (((hashsd[x] % MOD) * (hashsd[y] % MOD)) % MOD + (hashsd[x] ^ hashsd[y]) % MOD) % MOD;
}
int val[MOD];
bitset<MOD> ban;

inline void initHashSeed()
{
    for (int i = 1; i <= n; i++)
        hashsd[i] = abs((ll)rng());
}
```

然后我们就可以把“边权”和“是否被删”这两个信息按哈希值作为下标，存在一个数组里。显然 $MOD$ 越小、$n$ 越大，哈希冲突的风险就越高。然而事实证明 $n=10^5$ 的时候这个风险有点太高了...

为了解决可能的哈希冲突，不能简单地开一个线性数组，而应该把一个哈希值可能对应的所有边的信息都存起来，再手写一个简单的带冲突处理的哈希表：

```c++
struct Edge
{
    Edge(int _a = 0, int _b = 0, int _v = 0, bool _ba = false) : va(min(_a, _b)), vb(max(_a, _b)), val(_v), ban(_ba) {}
    int va, vb, val;
    bool ban;
};

ll hashsd[MAXN];
inline int edgeHash(int x, int y)
{
    return (((hashsd[x] % MOD) * (hashsd[y] % MOD)) % MOD + (hashsd[x] ^ hashsd[y]) % MOD) % MOD;
}
vector<Edge> hashTable[MOD];
inline Edge getEdge(int x, int y)
{
    if (x > y)
        swap(x, y);
    int hs = edgeHash(x, y);
    for (Edge e : hashTable[hs])
    {
        if (e.va == x && e.vb == y)
            return e;
    }
    return Edge();
}
inline void setEdge(int x, int y, Edge data)
{
    if (x > y)
        swap(x, y);
    int hs = edgeHash(x, y);
    for (int i = 0; i < hashTable[hs].size(); i++)
    {
        if (hashTable[hs][i].va == x && hashTable[hs][i].vb == y)
        {
            hashTable[hs][i] = data;
            return;
        }
    }
    hashTable[hs].push_back(data);
}
```

加上这一套就能拿下 60 分了。
