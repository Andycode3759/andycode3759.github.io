---
title: 题解 - UVA10048 Audiophobia 噪音恐惧症
date: 2023-10-10 13:18:28 +0800
categories: [题解]
tags: [uva]
math: true
---

> 注：洛谷上本题已经关闭题解通道，故只能发在个人博客里。没打算申请加入主题解区。

在题解区逛了一圈全是 Floyd / Dijkstra ~~（有一个 Kruskal 生成树除外）~~，难道求最大值最小就没人写二分答案吗...

先套一个二分框架，检验在最大边权不超过 $lim$ 的情况下是否存在从 $c_1$ 到 $c_2$ 的连通路径。这是很好办的，只需要一个简单的 DFS 就行了。题目里还说要先判断 $c_1$ 和 $c_2$ 是否存在路径，直接让 $lim=\infty$ 跑一遍已经写好的 DFS 即可。

另外，记得每次询问前清空标记数组，以及注意 UVA 的坑爹换行符检查，否则喜提 Presentation Error ~~（这个错误的存在让人百思不得其解，只能说明你的答案对了但是因为 OJ 不高兴导致不让你过）~~。

```c++
int c, s, q;

struct Edge
{
    Edge(int _t, int _v) : to(_t), val(_v) {}
    int to, val;
};
vector<Edge> G[MAXN];

bool vis[MAXN];
inline void clearVis()
{
    for (int i = 1; i <= c; i++)
        vis[i] = false;
}
// 检查在所有经过的边权不超过lim的情况下是否存在从u到target的路径
bool dfsConnect(int u, int target, int lim)
{
    if (u == target)
        return true;
    if (vis[u])
        return false;
    vis[u] = true;
    for (Edge e : G[u])
    {
        if (e.val > lim)
            continue;
        if (dfsConnect(e.to, target, lim))
            return true;
    }
    return false;
}

int main()
{
    int Kase = 1;
    while (scanf("%d %d %d", &c, &s, &q) == 3)
    {
        if (c == 0 && s == 0 && q == 0)
            break;

        // 如果把printf("\n")丢在每个Case的末尾就会爆PE
        if (Kase > 1)
            printf("\n");
        // 多组不清空，爆零两行泪
        for (int i = 1; i <= c; i++)
            G[i].clear();
        printf("Case #%d\n", Kase++);

        for (int i = 1; i <= s; i++)
        {
            int u, v, x;
            scanf("%d %d %d", &u, &v, &x);
            G[u].push_back(Edge(v, x));
            G[v].push_back(Edge(u, x));
        }
        while (q--)
        {
            int c1, c2;
            scanf("%d %d", &c1, &c2);
            clearVis();
            if (!dfsConnect(c1, c2, INF))
            {
                printf("no path\n");
                continue;
            }
            int l = 0, r = INF, mid = (l + r) >> 1, ans = mid;
            while (l <= r)
            {
                mid = (l + r) >> 1;
                clearVis();
                if (dfsConnect(c1, c2, mid))
                {
                    ans = mid;
                    r = mid - 1;
                }
                else
                {
                    l = mid + 1;
                }
            }
            printf("%d\n", ans);
        }
    }
    return 0;
}
```
