---
title: 考试总结 - 2023.11.12 NOIP 模拟赛
date: 2023-11-12 22:19:01 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## $T_1$

很重要的条件之一是使用一次科技可以让已经买了的**所有**植物的生长阶段都增加，而不是一次增加一株。

如果固定了使用科技的次数 $t$，那么买一株植物就相当于有了 $t$ 个价格可以选择，即 $[a_{i-t},a_i]$（减法需要稍微处理，可以把原序列复制一份首尾相连），显然要取最小的。区间最小可以 ST 表，也可以在计算时用单调队列动态维护。这样就有了一个 $O(n^2)$ 的做法，即枚举 $t$。

但是这还不够，打个表发现对于不同的 $t$，算出来的结果会呈现为单谷（最小值左边递减，右边递增），于是就可以二分/三分求最值了，成功优化到 $O(n \log n)$。

因为不会三分，所以写了个二分+判断中点处单调性走向，即计算 $t$ 取 $mid-1,mid,mid+1$ 三个值时的答案，如果递增就缩右边界，递减就缩左边界，如果中点比左右都小就得到了答案。这个写法对于 $n$ 很小时很容易挂（大的 $n$ 也有极小概率挂），所以稍微切了一下 Subtask。

## $T_2$

### Subtask 1

先搞出一个区间最值下标的 ST 表，然后 $O(n^2)$ 暴力枚举所有子区间。

```c++
stInit();
ll ans = 0;
for (int l = 1; l <= n; l++)
{
    for (int r = l + 1; r <= n; r++)
    {
        int mn = stQueryMin(l, r), mx = stQueryMax(l, r);
        if (mn != l && mn != r && mx != l && mx != r)
            ans++;
    }
}
printf("%lld\n", ans);
```

### Subtask 1.5

发现了一个有意思的分治做法：对于一个区间 $[l,r]$，先求出它的最大最小值所在位置 $x,y$。至于谁是最大谁是最小不重要，不妨令 $x<y$，那么所有左端点在 $[l,x-1]$、右端点在 $[y+1,r]$ 的子区间都是合法的，因为它们把最值包在了里面。

这样就计算出了左端点极值是 $l$、右端点极值是 $r$ 的子序列个数，接下来再分治计算 $[l,y-1]$ 和 $[x+1,r]$。但是这样会使得左端点极值为 $x+1$、右端点极值为 $y-1$ 的子序列被计算两次，因此还要再分治计算 $[x+1,y-1]$ 并减去其结果。

由于需要对中间一段子区间进行容斥，并不能做到 $O(n \log n)$，分数和暴力一样。

```c++
ll divide(int l, int r)
{
    if (r - l <= 1)
        return 0;
    int x = stQueryMin(l, r), y = stQueryMax(l, r);
    if (x > y)
        swap(x, y);
    ll res = (ll)(x - l) * (r - y);
    res += divide(l, y - 1);
    res += divide(x + 1, r);
    res -= divide(x + 1, y - 1);
    return res;
}
```

### Subtask 2

其实可以直接容斥计算答案：答案 = 所有区间个数 - 最大值开头的区间个数 - 最小值开头的区间个数 - 最大值结尾的区间个数 - 最小值结尾的区间个数 + 最大值开头且最小值结尾的区间个数 + 最小值开头且最大值结尾的区间个数。

前面四项比较好算，以最大值开头的区间为例，从 $1$ 到 $n$ 扫整个区间，维护一个递增的单调栈（简称小顶栈），可以求出每一个数的下一个比它大的数的位置，记作 $r_i$。对于后面不存在更大的数的位置，规定$r_i=n+1$。那么第一项的值就是 $\sum_{i=1}^{n}r_i-i-1$。

同理，把这份代码复制成 4 份，分别改成顺序扫/倒序扫+大顶栈/小顶栈，就可以求出前面所有四项的值。

后面两项的计算有点技巧。以最大值开头且最小值结尾的区间为例，因为已经计算出了 $r_i$，即对于一个位置 $i$ 来说，满足条件的区间有 $[i,i+1],[i,i+2],...,[i,r_i-1]$。那么 $\forall j \in [i+1,r_i-1]$，如果有 $j$ 满足 $a_j$ 是 $[i+1,j]$ 区间内的最小值，就找到了一个最大值开头、最小值结尾的区间。满足这样条件的 $j$ 也可以用单调栈求，从后往前扫并维护一个小顶栈，就知道目前在 $i$ 后面并且比 $a_i$ 小的数有多少，之后再在单调栈里二分查找 $r_i$ 就可以知道有多少个 $j$ 了。

```c++
int nxtMx[MAXN], nxtMn[MAXN], prvMx[MAXN], prvMn[MAXN];
ll r1, r2, r3, r4;
ll s1, s2;
int stk[MAXN], top = 0;

inline int find(int lim, int k)
{
    int l = 1, r = lim, t = lim;
    while (l <= r)
    {
        int mid = (l + r) >> 1;
        if (stk[mid] <= k)
            r = mid - 1, t = mid;
        else
            l = mid + 1;
    }
    return lim - t + 1;
}

int main()
{
    freopen("interval.in", "r", stdin);
    freopen("interval.out", "w", stdout);

    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", arr + i);

    // nxtMx
    for (int i = 1; i <= n; i++)
    {
        while (top > 0 && arr[i] > arr[stk[top]])
            nxtMx[stk[top--]] = i;
        stk[++top] = i;
    }
    while (top > 0)
        nxtMx[stk[top--]] = n + 1;
    for (int i = 1; i <= n; i++)
        r1 += nxtMx[i] - i - 1;

    // nxtMn
    // ...

    // prvMx
    // ...

    // prvMn
    // ...

    // [mx,mn]
    for (int i = n; i >= 1; i--)
    {
        while (top > 0 && arr[i] < arr[stk[top]])
            top--;
        stk[++top] = i;
        s1 += find(top, nxtMx[i] - 1) - 1;
    }
    top = 0;

    // [mn,mx]
    // ...

    ll ans = (ll)n * (n - 1) / 2;
    ans -= r1 + r2 + r3 + r4;
    ans += s1 + s2;
    printf("%lld\n", ans);
    return 0;
}
```

## $T_3$

### Subtask 1

手玩一下可以发现这个规律：设 $str$ 是给定的字符串，$full$ 是生成后的完整字符串，那么**先把 $str$ 倒序一下**，就有 $\forall i \in [1,2^n-1],full_i=str_{ffs(i)}$，其中 $ffs(x)$ 表示 $x$ 的二进制最低位 $1$ 的下标（从 $1$ 开始），或者说 $ffs(x) = 1+\log_2 \operatorname{lowbit}(x)$。

可以用这个规律把 $full$ 生成出来，然后 $O(2^{2^n})$ 枚举子序列 + 哈希 + `set` 暴力解决。

考场上没有发现需要把 $str$ 倒序，给的样例又刚好都是回文等价的串，以为推对了规律，导致 $50 \to 15$（悲）。

```c++
int n;
char str[MAXN];

char full[(1 << 20) + 5];
mt19937_64 rng(time(0));
ull hsh[(1 << 20) + 5];
unordered_set<ull> S;
inline void solve1()
{
    reverse(str + 1, str + 1 + n); // 一定要加上这一句！！
    int tot = (1 << n) - 1;
    for (int i = 1; i <= tot; i++)
        hsh[i] = rng();
    for (int i = 1; i <= tot; i++)
        full[i] = str[__builtin_ffs(i)];

    for (int s = 1; s < (1 << tot); s++)
    {
        int cnt = 1;
        ull cur = 0;
        for (int i = 0; i < tot; i++)
        {
            if (s & (1 << i))
                cur ^= (full[i + 1] - 'a' + 1) * hsh[cnt++];
        }
        S.insert(cur);
    }
    printf("%d\n", S.size() % MOD);
}
```

### Subtask 2

都可以 $O(2^n)$ 求 $full$ 了，对于 $n \leq 20$ 的点肯定不能放过。考虑怎么在线性时间内求出一个字符串有多少个不同的子序列。

设 $dp(c,i)$ 表示右端点极值为 $i$，以 $c$ 字符结尾的不重复子序列数量。转移如下：设第 $i$ 个字符是 $c_0$，要么保留原有的子序列（$\forall c \not = c_0,dp(c,i)=dp(c,i-1)$），要么给所有子序列末尾加上 $c_0$（$dp(c_0,i)=1+\sum_{c=[\texttt{a-z}]} dp(c,i-1)$）。加 $1$ 是因为包括单独的一个 $c_0$ 字符。方案数是覆盖而不是累加，因为“曾经被 $c_0$ 加过”和“在位置 $i$ 被 $c_0$ 加过”会产生等价的两个子序列。

容易发现 $i$ 一维可以直接滚掉，而且目前所有状态数之和可以动态维护，这样就可以避免每次转移都枚举 $c$ 求和从而少了个 $26$ 的常数。时间成功优化到 $O(2^n)$。

```c++
int dp[30];
int sum = 0;
inline void solve2()
{
    reverse(str + 1, str + 1 + n);
    int tot = (1 << n) - 1;
    for (int i = 1; i <= tot; i++)
        full[i] = str[__builtin_ffs(i)];

    for (int i = 1; i <= tot; i++)
    {
        int c = full[i] - 'a' + 1;
        int ns = ((ll)2 * sum + 1 - dp[c] + MOD) % MOD;
        dp[c] = (sum + 1) % MOD;
        sum = ns;
    }
    printf("%d\n", sum);
}
```

## $T_4$

### Subtask 1

$n \leq 100,m \leq 200$ 的小数据可以直接枚举删掉的一条/两条边，然后 DFS 判连通性，毫无技术含量的 5 分。

$k=1$ 的情况直接上求割边的板子即可。考试时调了比较长时间，说明还没练熟。

### Subtask 2

$k=2$ 但 $n \leq 2 \times 10^3$ 的情况可以考虑这样做：只删一条边的方案还是求割边，删两条边的方案可以先枚举删掉的第一条边，然后再求割边数量。但是考场上写挂了，搞成了 $O(nm)$ 枚举第二条删掉的边再检验。
