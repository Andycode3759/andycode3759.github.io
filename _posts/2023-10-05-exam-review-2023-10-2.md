---
title: 考试总结 - 2023.10.2
date: 2023-10-05 16:36:05 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## Problem T1

上次是没对拍，这次是轮到没开 `long long` 了。解法没问题，这次来订正一下数据生成器。

这题由于爆 `int` 的情况比较极限，如果随便造个一般的大数据很难发现问题，因此在对拍生成数据的时候就要拉到最大强度：

```c++
int n, m;
unordered_set<int> G[N + 5];
int perm[N + 5];
inline void generate()
{
    for (int i = 1; i <= n; i++)
        G[i].clear();

    n = N;
    m = randInt(1, max(1LL, min((long long)n * (n - 1) / 2, (long long)M)));
    fprintf(input, "%d %d\n", n, m);

    // 权值
    for (int i = 1; i <= n; i++)
    {
        // 这个地方原本写的是
        // fprintf(input, "%d ", randInt(1, 100000));
        // 这样就很难构造出爆int的数据，至少要下面这样才能达到极限情况：
        fprintf(input, "%d ", randInt(80000, 100000));
    }
    fprintf(input, "\n");

    // 构造图
    for (int i = 1; i <= m; i++)
    {
        int u = randInt(1, n);
        int v = randInt(1, n);
        // 去自环和重边
        while (u == v || G[u].count(v) == 1)
            u = randInt(1, n), v = randInt(1, n);
        G[u].insert(v);
        G[v].insert(u);
        fprintf(input, "%d %d\n", u, v);
    }

    // 随机排列
    for (int i = 1; i <= n; i++)
        perm[i] = i;
    random_shuffle(perm + 1, perm + 1 + n, RandFunctor());
    for (int i = 1; i <= n; i++)
        fprintf(input, "%d ", perm[i]);
    fprintf(input, "\n");
}
```

很匪夷所思的是，在写暴力的时候都想到了权值要开 `long long`，但是开始写正解时就没想到，还是后来补的，然后就遗漏了两处。所以，做题时要么一开始就不要犯错，要么要有足够的查错能力和考虑周全的思维，才能确保万无一失。

## Problem T2

表面上吓人、实际上很简单 ~~（但也算不上送分）~~ 的打表题。首先把 $f(n,k)$ 的解析式展开成递归结构是应该要想到的，考试时就是因为想复杂了导致后面的全都搞不出来：

$$
f(n,k) = \sum^{n}_{x_1=0} (C^{x_1}_{n} \cdot \sum^{x_1}_{x_2=0}(C^{x_2}_{x_1} \cdot \sum^{x_2}_{x_3=0}(...))) = \sum^{n}_{x_1=0} (C^{x_1}_{n} \cdot f(x_1,k-1)), f(n,0)=1
$$

然后把数学式子写成代码，就可以打表了：

```c++
const int MOD = 998244353;
const int MAXN = 200005;

int n;
int frac[MAXN], fracRev[MAXN];
inline int quickPow(int n, int x)
{
    int res = 1;
    while (x > 0)
    {
        if ((x & 1) == 1)
            res = (long long)res * n % MOD;
        n = (long long)n * n % MOD;
        x >>= 1;
    }
    return res;
}
inline void init()
{
    frac[0] = 1;
    for (int i = 1; i < MAXN; i++)
    {
        frac[i] = (long long)frac[i - 1] * i % MOD;
    }
    fracRev[MAXN - 1] = quickPow(frac[MAXN - 1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--)
    {
        fracRev[i] = (long long)fracRev[i + 1] * (i + 1) % MOD;
    }
}
inline int C(int n, int m)
{
    return (long long)frac[n] * fracRev[m] % MOD * fracRev[n - m] % MOD;
}

// 关键在这里
inline int F(int n, int k)
{
    if (k == 0)
        return 1;
    int sum = 0;
    for (int i = 0; i <= n; i++)
        sum = (sum + (long long)C(n, i) * F(i, k - 1) % MOD) % MOD;
    return sum;
}
int main()
{
    init();
    for (int i = 0; i <= 10; i++)
    {
        for (int j = 0; j <= 10; j++)
        {
            printf("%10d", F(i, j));
        }
        printf("\n");
    }
    return 0;
}
```

于是就可以发现：$f(n,k)=(k+1)^n$。~~当然不打表也可以用数学方法推导出来，但是对于数学渣渣来说还是打表来得方便。~~

接下来就考虑怎么计算答案：

$$
\sum^{n}_{i=0}f(f(n,i),i)
= \sum^{n}_{i=0}f((i+1)^n,i)
= \sum^{n}_{i=0} (i+1)^{(i+1)^n}
$$

记 $g(x,n)=x^{x^n}$，答案就是 $\sum^{n}_{i=0}g(i+1,n) \bmod P$。那又该怎么计算 $g$ 函数呢？显然不能套两层快速幂，因为连幂不具有和加减乘一样的同余性质。

这时每天在快速幂求逆元中当作模板用而其本质已经被淡忘的**费马小定理**就派上用场了。首先是那个每天当模板背的公式：

$$
x^{-1} \equiv x^{P-2} \bmod P, P是质数
$$

它的真身，也就是费马小定理的原始形态，只要两边同乘一个 $x$ 就能得到：

$$
x^0 \equiv 1 \equiv x^{P-1} \bmod P
$$

再根据幂运算性质，把 $g$ 的表达式拆分一下：

$$
g(x,n)=x^{x^n}=x^{P-1} \cdot x^{P-1} \cdot \dots \cdot x^{ {x^n} \bmod {P-1} }
$$

而前面所有的 $x^{P-1}$ 都相当于 $1$，于是就得到了：$g(x,n)=x^{ {x^n} \bmod {P-1} }$，这样就可以方便计算了。

最后一个小坑点：$P=998244\bold{8}53$（不是 $998244\bold{3}53$），不要手滑打错了。

## Problem T3

### Subtask 1：暴力（15%）

枚举若干个集合组合的 DFS 之前写的比较少，考试时直接上了个全排列+切分，很自然地挂掉了。这次需要整理一下套路。

把 $n$ 个元素分成最多 $k$ 个集合，以元素为单位进行决策。DFS 中需要记录两个信息：当前考虑的元素，和目前已经开出来的集合数量。每个元素有两个选择，开出一个新集合并把它放进去（如果还没开满 $k$ 个集合），或者放进之前的开过的任意一个集合中。

```c++
Line S[MAXN];
int ans = 0;
void dfs(int step, int maxK)
{
    if (step > n)
    {
        int sum = 0;
        for (int i = 1; i <= maxK; i++)
        {
            sum += S[i].r - S[i].l;
        }
        ans = max(ans, sum);
        return;
    }

    // 开新集合
    if (maxK < k)
    {
        Line bk = S[maxK + 1];
        S[maxK + 1] = S[maxK + 1] + lines[step];
        dfs(step + 1, maxK + 1);
        S[maxK + 1] = bk;
    }

    // 放进已有集合
    for (int i = 1; i <= maxK; i++)
    {
        Line bk = S[i];
        S[i] = S[i] + lines[step];
        dfs(step + 1, maxK);
        S[i] = bk;
    }
}
```

问题变形：

- 分成恰好 $k$ 个集合，允许有空集：直接在最开始开好 $k$ 个集合，决策就只剩下放进这 $k$ 个集合中；
- 分成恰好 $k$ 个集合，不允许有空集：在最开始开好 $k$ 个集合，决策只剩下放进这 $k$ 个集合中，DFS 过程中记录目前的空集数量，只有在空集数量为 0 时才统计答案；
- 分成至少 $k$ 个集合：在最开始开好 $k$ 个集合（或者到达边界时没到 $k$ 个集合不统计答案），新开集合时去掉集合数量上限。

## Problem T4
