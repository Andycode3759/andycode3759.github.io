---
title: 考试总结 - 2023.9.20
date: 2023-09-22 17:32:42 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## Problem T1

## Problem T2

### Subtask 1：$n=2,m=2$（10%）

显然分两个元素相同或不同来讨论。样例 1 已经暗示的相当明显，这些情况都是可以直接数学推导出来的，甚至直接给出了一半的答案。但是本人作为数学渣渣推不出来，所以选择枚举打表：

```c++
inline int getF(long long s, int len)
{
    int i = 1;
    for (; i < len; i++)
    {
        if (((s & (1LL << (i - 1))) != 0) && ((s & (1LL << i)) != 0)) // 这里当作两个1处理
        {
            return i + 1;
        }
    }
    return -1;
}
int main()
{
    long long tot = 0, cnt = 0;
    // 枚举所有可能的A
    for (int len = 2; len <= 32; len++) // 长度
    {
        for (long long s = 0; s < (1LL << len); s++) // 二进制状态（0/1）
        {
            int f = getF(s, len); // 根据两个参数算出B出现在哪个位置，没有找到则返回-1
            if (f != -1)
            {
                cnt++;
                tot += f;
            }
        }
        printf("%lf\n", 1.0 * tot / cnt);
    }
    return 0;
}
```

尽管效率感人，但结果还是很明显地趋近于 $6$。于是大胆猜想，果然碰到 10 分。

## Problem T3

### Subtask 1：暴力（40%）

各种花式的 $O(n^2)$ 做法都是这个分数。赛时的想法是：显然合法区间的长度必须是 $m$ 的整数倍，那就枚举长度再枚举左端点，向右转移时可以 $O(1)$ 修改当前区间的各个数出现次数，再检查计数就行了。

看上去框架似乎是 $O(n^2/m)$ 的，但实际上暴力检查需要 $O(m)$，所以本质依然是 $O(n^2)$。

```c++
int n, m;
int arr[MAXN], cnt[MAXN];
inline bool checkCnt()
{
    for (int i = 2; i <= m; i++)
    {
        if (cnt[i] != cnt[i - 1])
        {
            return false;
        }
    }
    return true;
}
inline void solve2()
{
    int ans = 0;
    for (int len = m; len <= n; len += m)
    {
        for (int i = 1; i <= m; i++)
        {
            cnt[i] = 0;
        }
        for (int i = 1; i <= len; i++)
        {
            cnt[arr[i]]++;
        }
        if (checkCnt())
            ans++;
        for (int l = 2; l + len - 1 <= n; l++)
        {
            cnt[arr[l - 1]]--;
            cnt[arr[l + len - 1]]++;
            if (checkCnt())
                ans++;
        }
    }
    printf("%d\n", ans);
}
```

### Subtask 2：暴力优化（70%）

如果想要得到真正的 $O(n^2/m)$ 做法，就需要把检查优化至 $O(1)$。可以用哈希来实现。把 `cnt` 数组当作是一个字符串进行哈希，先把值全为 $1$ 时的哈希值算出来，记作 $H$；转移区间修改时在相应位上 +1 或 -1，检查哈希值是否为 $H$ 的倍数即可。

### Subtask 3：随机化（80%）

可以考虑对 $[1,m]$ 内的每一个数分配一个权值 $wei(x)$，令 $\sum_{i=1}^{m}wei(i)=0$，这样如果把一段区间内的所有数对应的 $wei(x)$ 加起来为 $0$ 的话，这段区间就是合法的。区间和为 $0$ 等价于两个位置的前缀和相同，所以可以把前缀和数组里所有不同元素的个数数出来，分别算出 $C_x^2$（表示这些位置里任选 2 个都可以组成一个合法区间），累加即得答案。

至于 $wei(x)$ 怎么分配，那当然是 `mt19937`。一种比较科学的分配方法是，令 $[1,m-1]$ 的权值为随机生成的正整数，$m$ 的权值取前面权值和的相反数，同时 $wei(x)$ 的值域越大越好。这样可以把数错的可能性降到最低。

```c++
mt19937 rd;
inline int C2(int x)
{
    return (x - 1) * x / 2;
}
int n, m;
int arr[MAXN];
long long hashWeight[MAXN];

unordered_map<long long, int> cnt;
inline void solve2()
{
    long long sum = 0;
    for (int i = 1; i < m; i++)
    {
        hashWeight[i] = rd();
        sum += hashWeight[i];
    }
    hashWeight[m] = -sum;
    cnt.clear();
    long long nowHash = 0;
    for (int i = 1; i <= n; i++)
    {
        nowHash += hashWeight[arr[i]];
        cnt[nowHash]++;
    }
    cnt[0]++;
    int ans = 0;
    for (auto it = cnt.begin(); it != cnt.end(); it++)
    {
        ans += C2(it->second);
    }
    printf("%d\n", ans);
}
```

### Subtask 4：AC（100%）

还是基于上面的随机化做法，有两条优化路径：一是把 `unordered_map` 换成自己手写的数据结构，比如哈希表之类的，卡一卡就能过；二是换一种 `cnt` 的统计思路。

基于“合法区间的长度必须是 $m$ 的整数倍”这一事实，假如出现了一连串首位相连的合法区间，那么它们的“切分点”坐标一定满足 $mx+k,\ k<m$。不难发现，只需要变换 $x$ 和 $k$，即可得到所有合法区间的端点位置。于是可以枚举 $k$，每隔 $m$ 个位置统计一个前缀和数，用一种比较快的方式算出它们对答案的贡献，这样在换到下一个 $k$ 时就可以直接把上次统计过的给清空而不影响答案正确性。每次统计的数据个数都是 $O(n/m)$ 量级的，也没必要用 `unordered_map` 了，排序后直接算就行。时间几乎为 $O(n)$。

```c++
mt19937 rd;
int n, m;
int arr[MAXN];
long long hashWeight[MAXN], prew[MAXN], pres[MAXN];
// 顺便一提，hashWeight应该在处理多组样例前先预处理好，避免重复计算浪费时间
vector<long long> V;
inline void solve2()
{
    long long ans = 0;
    long long goodVal = prew[m];
    for (int i = 1; i <= n; i++)
        pres[i] = pres[i - 1] + hashWeight[arr[i]];
    for (int k = 0; k < m; k++)
    {
        V.clear();
        for (int s = 0; s * m + k <= n; s++)
        {
            V.push_back(pres[s * m + k] - s * goodVal);
        }
        sort(V.begin(), V.end());
        int combo = 1;
        for (int i = 1; i < V.size(); i++)
        {
            if (V[i] != V[i - 1])
            {
                ans += 1LL * combo * (combo - 1) / 2;
                combo = 1;
            }
            else
            {
                combo++;
            }
        }
        ans += 1LL * combo * (combo - 1) / 2;
    }
    printf("%lld\n", ans);
}
```

## Problem T4

### Subtask 1：暴力，$n \leq 20$（30%）

### Subtask -1：模拟退火（0%）

### Subtask 2：AC（100%）
