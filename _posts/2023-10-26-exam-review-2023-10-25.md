---
title: 考试总结 - 2023.10.25
date: 2023-10-26 21:28:06 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## `soldier` - 兵

### Subtask 1：$s=1$（50%）

可以转化为 01 背包，第 $i$ 个城堡的重量为 $2a_i+1$，价值为 $i$，然后直接套模板。

### Subtask 2：AC（100%）

每个城堡只能派一批人，而一个城堡的总收益取决于这批人数能够打败多少个 $a_i$。可以转化为分组背包，每个城堡视为一组，每组有 $s$ 个物品。先将同一城堡的所有玩家兵数进行排序，从小到大构建物品，第 $j$ 个物品的重量为 $2a_j+1$，价值为 $i \times j$。然后又可以直接套模板了。因为要给每个城堡的 $a$ 排序，所以定义数组的时候需要把第一、二维的定义交换一下，改成“第 $i$ 个城堡中第 $j$ 个玩家的策略”，而不是按题目给的顺序。

其实还有一个小优化：同一个城堡中的 $a$ 大概率有很多重复的，可以只取相同重量中最大价值的物品。但是效果并不明显，而且没有优化也可以毫无压力通过此题。

```c++
int s, n, m;
int ply[MAXN][MAXN];

ll dp[MAXN][20005];
vector<pair<int, int>> grp[MAXN]; // wei, val
inline void solve1()    // Subtask 1
{
    for (int i = 1; i <= n; i++)
        grp[1].push_back({2 * ply[i][1] + 1, i});
    for (auto p : grp[1])
    {
        for (int j = m; j >= p.first; j--)
        {
            dp[0][j] = max(dp[0][j], dp[0][j - p.first] + p.second);
        }
    }
    printf("%lld\n", dp[0][m]);
}

map<int, int> M;    // 用于去除重复重量
inline void solve2()    // Subtask 2
{
    for (int i = 1; i <= n; i++)
    {
        sort(ply[i] + 1, ply[i] + 1 + s);
        grp[i].push_back({0, 0});   // 这个空物品不能省
        M.clear();
        for (int j = 1; j <= s; j++)
        {
            if (2 * ply[i][j] + 1 > m)  // 无用的物品（一定装不下）可以直接省略
                break;
            int wei = 2 * ply[i][j] + 1, val = j * i;
            if (M.count(wei))
                M[wei] = max(M[wei], val);
            else
                M[wei] = val;
        }
        for (auto p : M)
            grp[i].push_back(p);
    }

    for (int g = 1; g <= n; g++)
    {
        for (auto p : grp[g])
        {
            for (int j = m; j >= p.first; j--)
            {
                dp[g][j] = max(dp[g][j], dp[g - 1][j - p.first] + p.second);
            }
        }
    }
    printf("%lld\n", dp[n][m]);
}
```

考场上发现对于分组背包还不是很熟练，调了比较长时间。

## `light` - 光

### Subtask 1：$n=1$（5%）

直接输出 $a_1$ 即可获得出题人施舍的 5 分。

### Subtask 2：$n=2$（20%）

考虑两层玻璃中间的夹缝处，假设光在这里面反射了 $2k$ 次后从下面射出，射出的量为 $a_1a_2(b_1b_2)^k$。所以答案是 $\sum_{k=0}^{\infty}a_1a_2(b_1b_2)^k$。

但是该怎么解呢？如果知道无穷级数求和公式的话（$\sum_{k=0}^{\infty}a^k={1 \over {1-a} }, \lvert a \rvert<1$）可以直接套，不知道也没关系，推导也很简单。设 $X=\sum_{k=0}^{\infty}a^k$，那就有 $a \cdot X=\sum_{k=1}^{\infty}a^k=X-1$，所以 $X={1 \over 1-a}$。总之解得答案为 ${ {a_1a_2} \over {1-b_1b_2} }$。

### Subtask 3：AC（100%）

延续 $n=2$ 的思路，既然一束光被反射 $2k$ 次后会从下面射出，那反射 $2k+1$ 次后就会从上面射出 ~~（这不是废话么）~~。从上面射出的光也可以用相同的方法算到，即 $b_1+\sum_{k=0}^{\infty}{a_1}^2b_2(b_1b_2)^k$，或者说 $b_1+{ { {a_1}^2 b_2} \over {1-b_1b_2} }$（别忘了加上第 $1$ 面镜子直接反射的光线）。换句话说，如果把这两面玻璃**等效**成一面，那么这面玻璃的透光率和反射率就分别是 ${ {a_1a_2} \over {1-b_1b_2} }$ 和 $b_1+{ { {a_1}^2 b_2} \over {1-b_1b_2} }$。然后就可以直接递推了！...吗？

其实并不是，因为在计算反射率时，它的值和光线从哪一面射入有关。上面的式子中我们认为光是从第 $1$ 面玻璃射入的，所以计算出的递推式会带有 $b_1$ 和 ${a_1}^2$。但实际上，一束光在两面玻璃间反射时，一定是从最下面进入上面那一块玻璃，又因为在计算等效玻璃时是从上往下计算的，所以应该考虑计算光**从最后一块玻璃入射**时的反射率。（本题一大坑点，都已经想到等效、离正解近在咫尺了，如果忽略了这一点就还是只能得 20 分）。

设前 $i$ 块玻璃的等效透光率与反射率分别为 $A_i,B_i$，那根据上面的结论就可以写出递推式：

$$
A_1=a_1,B_1=b_1 \\
A_i = { {A_{i-1}a_i} \over {1-B_{i-1}b_i} } \\
B_i = b_i + { { {a_i}^2 B_{i-1} } \over {1-B_{i-1}b_i} }
$$

然后就是带模运算不要漏必要的转化和取余就行了。或者嫌麻烦的话还可以把带模运算的有理数抽象成结构体并重载运算符（[板子参考](https://www.luogu.com.cn/blog/andycode3759/moded-num-struct)）。

## `paradox` - 矛

### Subtask 1：暴力模拟（10%）

修改 $O(1)$，统计 $O(n)$，最坏情况 $O(nq)$。

### Subtask 2：Readonly（+30%）

显然可以先离散化，预处理出每一个取值对应的答案。预处理可以考虑模拟：从高到低依次给值对应的位置打标记，同时维护目前有多少组。查询时直接在值的集合里 `lower_bound` 即可。

```c++
vector<int> V;
vector<int> pos[MAXN];
bool mark[MAXN];
int ans[MAXN];
inline void solve2()
{
    for (int i = 1; i <= n; i++)
        V.push_back(arr[i]);
    sort(V.begin(), V.end());
    int t = unique(V.begin(), V.end()) - V.begin();
    V.resize(t);
    for (int i = 1; i <= n; i++)
    {
        arr[i] = lower_bound(V.begin(), V.end(), arr[i]) - V.begin() + 1;
        pos[arr[i]].push_back(i);
    }
    int cnt = 0;
    for (int i = t; i >= 1; i--)
    {
        for (int x : pos[i])
        {
            if (!mark[x - 1] && !mark[x + 1])   // 两边都没有标记，说明是新的一组
                cnt++;
            else if (mark[x - 1] && mark[x + 1]) // 两边都有标记，会将两组合并成一组
                cnt--;
            mark[x] = true;
        }
        ans[i] = cnt;
    }
    ans[0] = 1;
    while (m--)
    {
        int op;
        scanf("%d", &op);
        if (op == 1)
        {
            int b;
            scanf("%d", &b);
            int idx = lower_bound(V.begin(), V.end(), b) - V.begin() + 1;
            if (idx > t)
                printf("0\n");
            else
            {
                printf("%d\n", ans[idx]);
            }
        }
        else if (op == 2)
        {
            return; // i gave up
        }
    }
}
```

### Subtask 3：AC（100%）

## `park` - 园

### Subtask 1：Readonly 树状 DP（2%）

一个很简单的树状 DP，设 $dp(x,u)$ 为以 $u$ 为根的子树，且 $u$ 的状态是 $x \in \{0,1\}$ 的最大答案。

```c++
struct Edge
{
    int to, idx;
};

int n, m, q;
int valW[MAXN], valS[MAXN];
int valC[MAXN], valD[MAXN];
int U[MAXN], V[MAXN];
vector<Edge> G[MAXN];

ll dp[2][MAXN];
void dfsDP(int fa, int u)
{
    dp[0][u] = valW[u];
    dp[1][u] = valS[u];
    for (Edge e : G[u])
    {
        int v = e.to;
        if (v == fa)
            continue;
        dfsDP(u, v);
        // u is w(0)
        dp[0][u] += max(dp[0][v] + valC[e.idx], dp[1][v] + valD[e.idx]);
        // u is s(1)
        dp[1][u] += max(dp[0][v] + valD[e.idx], dp[1][v] + valC[e.idx]);
    }
}
inline void solve1()
{
    dfsDP(0, 1);
    printf("%lld\n", max(dp[0][1], dp[1][1]));
}
```

考试的时候挂了是因为读入边的时候没有加双向边（当作单向边/有向图存了），下次写代码一定要长眼睛。

### Subtask 2：$Q \times 2^n$ 暴力（3%）

直接枚举就完事了，没啥好说的。

### Subtask 9：AC（100%）

~~严重超纲+越级，以后再来吧（~~

Solution by myee：<https://loj.ac/d/4040>
