---
title: 学习笔记 - 2-SAT
date: 2024-01-18 20:34:01 +0800
categories: [学习笔记]
tags: [2-sat]
math: true
---

**2-SAT** 用于描述这样一类问题：有 $2n$ 个两两成对的元素，一共组成 $n$ 对。现在需要从每一对中选取恰好一个元素，并且告诉你若干条形如“来自不同对的两个元素 $a$ 和 $b$ 只能二选一”的条件，求有没有一种取元素的方法使得所有这些条件都满足，如果有的话给出具体的一种取法。

## 模型构建

为了叙述方便，我们把 2-SAT 的一般问题形式换一种方法表述：有 $n$ 个布尔型变量 $x_1,x_2,\dots,x_n$，每个变量的取值只能是 $0$ 或 $1$，给出 $m$ 条形如“$x_i=a$ 和 $x_j = b$ 有且仅有一个成立”的条件，求是否存在满足所有条件的一组 $x_1,x_2,\dots,x_n$ 的解，若有则构造一组。

我们可以考虑把条件转化成更基本的形式，方便我们处理。通过简单的逻辑推理可以得到：

- 如果 $x_i=a$，那么必须要有 $x_j=\neg b$；
- 如果 $x_j=b$，那么必须要有 $x_i=\neg a$。

也就是说一句条件告诉了我们两个依赖关系，而依赖关系可以用有向图来构建。把 $x_i=p$ 这一命题抽象成一个点，那么一句条件就相当于连了两条边：

- $x_i=a \to x_j=\neg b$；
- $x_j=b \to x_i=\neg a$。

如何在程序中表示这些点呢？很简单，让 $x_i=a$ 对应到整数 $i+an$ 就行了，即：

- $x_i=1 \to i+n$
- $x_i=0 \to i$

也就是说在存图的时候需要两倍的空间。

## 判定是否有解

如果存在一个变量 $x_p$，使得我们能从 $x_p=0$ 推到 $x_p=1$，**同时**从 $x_p=1$ 推到 $x_p=0$，那就说明这个变量无论取何值都不能满足所有条件，因为一定会出现自相矛盾。注意一定要双向路径都存在，因为我们不能从其中一条推出另一条（比如，$x_p=0 \to x_p=1$ 无法说明 $x_p=1 \to x_p=0$，只需要令 $x_p=1$ 就不会产生自相矛盾）。

$x_p=0$ 和 $x_p=1$ 两个点双向可达，不禁让我们想起有向图的强连通分量。于是我们就找到了判定 2-SAT 问题是否有解的算法：构出图后用 Tarjan 算法进行缩点，对于每一个点 $p \in [1,n]$ 检测 $p$ 与 $p+n$ 是否在同一强连通分量内，若存在则说明无解。复杂度 $O(n+m)$。

```c++
int n, m;
vector<int> G[MAXN * 2];
stack<int> S;
bitset<MAXN * 2> vis, ins;
int dfn[MAXN * 2], low[MAXN * 2], scc[MAXN * 2], sccTot;
int curt = 0;
void dfsTarjan(int u)
{
    dfn[u] = low[u] = ++curt;
    vis[u] = true;
    S.push(u);
    ins[u] = true;
    for (int v : G[u])
    {
        if (vis[v])
        {
            if (ins[v])
                low[u] = min(low[u], dfn[v]);
        }
        else
        {
            dfsTarjan(v);
            low[u] = min(low[u], low[v]);
        }
    }
    if (dfn[u] == low[u])
    {
        sccTot++;
        while (!S.empty() && S.top() != u)
        {
            scc[S.top()] = sccTot;
            ins[S.top()] = false;
            S.pop();
        }
        scc[S.top()] = sccTot;
        ins[S.top()] = false;
        S.pop();
    }
}

int main()
{
    ...
    for (int i = 1; i <= n * 2; i++)
    {
        if (!vis[i])
            dfsTarjan(i);
    }
    for (int i = 1; i <= n; i++)
    {
        if (scc[i] == scc[i + n])
        {
            printf("IMPOSSIBLE\n");
            return 0;
        }
    }
    printf("POSSIBLE\n");
    return 0;
}
```

## 构造解

其实构造解的方法就藏在上一段某句话的括号里：

> 比如，$x_p=0 \to x_p=1$ 无法说明 $x_p=1 \to x_p=0$，只需要令 $x_p=1$ 就不会产生自相矛盾。

无向图缩点后可以得到一张 DAG，这启发我们：如果在这张 DAG 上拓扑排序，$x_p=0$ 比 $x_p=1$ 的拓扑序更靠前，即存在 $x_p=0 \to x_p=1$ 的路径，那么我们就必须要让 $x_p=1$，反之亦然。

那……难不成还要再给缩完点的图跑一遍拓扑排序？其实没必要，因为求拓扑序的过程已经在 Tarjan 算法中顺便完成了。Tarjan 会根据 `dfn[u]==low[u]` 的点来“打包”强连通分量，并且这个过程是**逆拓扑序**的——打包发生在遍历完所有 DFS 树儿子之后。也就是说，拓扑序越靠前的强连通分量，其编号就越大（因为越靠后被打包，比如 $1$ 号点所在的强连通分量一定是最后一个被打包的）。那么我们只需要在点 $p$ 和 $p+n$ 之间选择 $scc$ 编号更小的那一个就可以了。

```c++
for (int i = 1; i <= n; i++)
{
    if (scc[i + n] < scc[i])
        printf("1 ");
    else
        printf("0 ");
}
```

## 例题

**提示**：大多数 2-SAT 题目会在条件形式上玩花样，但它们最后一定都可以等价于 $(x_p=a \to x_q=b) \cap (x_q=\neg b \to x_p=\neg a)$ 的样子（简记为**交换首尾，条件取反**）。

- 【模板】 2-SAT - [洛谷](https://www.luogu.com.cn/problem/P4782)
- [POI2001] 和平委员会 - [洛谷](https://www.luogu.com.cn/problem/P5782) / [LOJ](https://loj.ac/p/10097)
- [JSOI2010] 满汉全席 - [洛谷](https://www.luogu.com.cn/problem/P4171)

### 更多的提示

为了避免不小心看到导致影响做题体验，提示内容已被 Base64 编码。你可以在 Linux 系统上通过以下命令进行解码：`echo "base64编码串" | base64 -d`，或者使用[在线解码工具](https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode)。

```plaintext
【模板】 2-SAT
5Y+v5Lul6L+Z5qC36L2s5YyW5p2h5Lu277yaeFtpXT09YXx8eFtqXT09YiAtPiDoi6UgeFtpXT0h
YSDliJkgeFtqXT1i77yM6IulIHhbal09IWIg5YiZIHhbaV09YeOAguS5i+WQjuWwseaYr+e6r+ao
oeadv+S6huOAggo=

[POI2001] 和平委员会
5ZSv5LiA55qE5bCP5Z2R54K55Zyo5LqO77yM6aKY55uu6ZmQ5a6a5LqG5Y+Y6YeP55qE57yW56CB
5pa55byP44CC5oiR5Liq5Lq65piv6L+Z5qC35pON5L2c55qE77yaCmlubGluZSBpbnQgcGFydG5l
cihpbnQgeCkgeyByZXR1cm4gKHggJiAxKSA/IHggKyAxIDogeCAtIDE7IH0gLy8geCDnmoTlkIzk
vJkKYSDlkowgYiDkuI3og73lkIzml7blh7rnjrDvvIzlj6/ku6XovazljJbkuLrigJzoi6Xlh7rn
jrAgYSDliJnlv4Xpobvlh7rnjrAgYiDnmoTlkIzkvJnigJ3vvIzigJzoi6Xlh7rnjrAgYiDliJnl
v4Xpobvlh7rnjrAgYSDnmoTlkIzkvJnigJ3jgILkuYvlkI7lj6ropoHlnKjnu4boioLkuIrms6jm
hI/kuIDkuIvnvJbnoIHmlrnlvI/lsLHooYzkuobvvIzmr5TlpoLku44gMSDliLAgbiDmnprkuL4g
ae+8jOmCo+S5iCAyKmktMSDlkowgMippIOWwseaYr+WQjOS8meOAgg==

[JSOI2010] 满汉全席
5Y+q6ZyA5Yik5a6a5piv5ZCm5pyJ6Kej5Y2z5Y+v77yM5peg6aG75p6E6YCg44CC5pyA6Zq+55qE
54K55Zyo5LqO6L6T5YWl55qE5aSE55CG77yM5Y+v5Lul5ben55SoIHNzY2FuZiDop6PlhrPvvIzl
iankuIvnmoTkvp3nhLbmmK/mqKHmnb/jgII=
```

## 参考文献

1. OI Wiki 贡献者.2-SAT - OI Wiki [EB/OL].2023:[2024-1-18].https://oi-wiki.org/graph/2-sat/.
2. 暗ざ之殇.2-SAT 知识小结 [EB/OL].2020:[2024-1-18].https://www.cnblogs.com/xcg123/p/11818059.html.
