---
title: 考试总结 - 2023.8.19 周练
date: 2023-08-20 21:09:31 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## 回顾

开题，四道题都看了一眼题意，觉得正解一分都不会。T2 相对比较好下手就从 T2 开始。

暴力和第一个特殊性质比较简单，半小时就写完了。之后开始在纸上推第二个特殊性质，推了很久没推出来，切到下一题。

T3 的暴力和特殊性质花了一个小时写完，两道题又重新检查了一遍，并简单地对了拍。

这时候又回到 T1，也是暴力和第一个特殊性质花了一个小时调对。剩余的时间不多了，赶紧切到 T4，还好暴力不是很复杂，十分钟写完。

剩下的时间全都在想 T2 可以怎么样多拿点分，但是没有任何进展。

分数有点难看。估计是前几天在济南每天做思维题做傻了，写代码的速度有所下降，例如 T3 完全用不着花上一个小时。再加上图论本来就是弱项，T1 相对比较送分的题目又更难拿分。数据结构和图论方面要加强练习，并且顺便把码力和思维能力进一步提升。

## `tree` - 果树

### Subtask 1：暴力（20%）

既然有 $k$ 个连通块，那就要删掉 $k-1$ 条边，枚举删掉的边再用并查集数出每个连通块的大小即可。时间复杂度 $O(n \cdot 2^k)$。

### Subtask 2：$k=2$（20%）

可以找出一条连接两点的路径，对于路径上的每一点数出其子树大小，问题就变成了把一个数组分成两段，使得两段各自的和的差值尽量小。形象地说，扯住两个果实作为端点，把整棵树拉直，再找中心线上的一条割边，使得把树从中间割断后两段的节点数尽可能接近。

```c++
vector<int> path;
bool vis[MAXN];
// 找到一条从cur到target的路径，返回值是是否能找到
bool dfsPath(int cur, int target)
{
    if (vis[cur])
        return false;
    vis[cur] = true;
    path.push_back(cur);
    if (cur == target)
        return true;
    for (int e = head[cur]; e != 0; e = G[e].nxt)
    {
        int v = G[e].dest;
        if (dfsPath(v, target))
            return true;
    }
    path.pop_back();
    return false;
}
// 数子树大小
int dfsCount(int cur)
{
    if (vis[cur])
        return 0;
    vis[cur] = true;
    int res = 1;
    for (int e = head[cur]; e != 0; e = G[e].nxt)
    {
        int v = G[e].dest;
        res += dfsCount(v);
    }
    return res;
}
int cnt[MAXN], preSum[MAXN], tot = 0;
inline void solve()
{
    int f1 = ff[0], f2 = ff[1];
    for (int i = 1; i <= n; i++)
        vis[i] = false;
    dfsPath(f1, f2);
    tot = path.size();
    for (int i = 0, len = path.size(); i < len; i++)
    {
        // 数子树大小的时候不能把路径上两端相邻的点给数进去
        for (int j = 1; j <= n; j++)
            vis[j] = false;
        if (i > 0)
            vis[path[i - 1]] = true;
        if (i < len - 1)
            vis[path[i + 1]] = true;
        cnt[i + 1] = dfsCount(path[i]);
    }
    // 做个前缀和
    for (int i = 1; i <= tot; i++)
    {
        preSum[i] = preSum[i - 1] + cnt[i];
    }
    int res = INF;
    // 枚举求答案
    for (int i = 1; i < tot; i++)
    {
        res = min(res, max(preSum[i], preSum[tot] - preSum[i]));
    }
    printf("%d\n", res);
}
```

### Subtask 3：$k=3$（20%）

如果三个果实中有一个在其它两者的路径上，那么和 $k=2$ 的情况一样，两等分改成三等分即可；

否则第三个果实一定会挂在另外两个果实的路径的某颗子树上。我们可以用与 $k=2$ 类似的做法，扯住三个果实把树拉开，形成一个“奔驰”，再枚举两条割边即可，注意两条割边不能处于“奔驰”的同一条杠上。

（此想法仅在理论上成立，代码写出来估计比正解还长）

### Subtask 4：AC（100%）

既然题目问的是最大值最小，那肯定考虑二分答案。关键是怎么在比较短的时间内判断一个答案是否可行。

可以利用贪心思想，一个果实能包括的节点在不超过给定答案（不妨称之为“容量”）的情况下自然越多越好。先把树转化为有根树，并且让一个果实作为整棵树的根。从根开始，对每个儿子进行贪心，让它们（和它们的儿子）中的果实尽可能多的“占领”节点。如果剩下的节点数（即树的大小减去刚刚被儿子占领过的节点数）大于容量，那么这个容量显然不能作为答案，否则就是 OK 的。

对于一颗根不是果实的子树，还需要考虑它内部是否有果实。如果有，那就尽量取子树大小小的果实，把剩下的没被分配的节点和它混在一起，“上报”给父节点要求重新分配；否则就把整棵子树一起上报给父节点。

```c++
int root;
vector<int> child[MAXN];
// 无向图转有根树
void dfsConvert(int cur, int fa)
{
    for (int e = head[cur]; e != 0; e = G[e].nxt)
    {
        int v = G[e].dest;
        if (v == fa)
            continue;
        child[cur].push_back(v);
        dfsConvert(v, cur);
    }
}
// 对于节点cur，检查一个容量是否合法
// 返回值中first表示没能被子结点果实所分配掉的剩余的节点个数
// second表示未分配节点中的果实数
pair<int, int> dfsCheck(int cur, int cap, bool &isOk)
{
    int minChild = INF;
    int freeNode = 1;
    for (int i = 0, len = child[cur].size(); i < len; i++)
    {
        int son = child[cur][i];
        pair<int, int> mem = dfsCheck(son, cap, isOk);
        if (!isOk)
            return {-1, -1};
        if (mem.second > 0) // 维护一个子树最小的子果实
            minChild = min(minChild, mem.first);
        else
            freeNode += mem.first;
    }
    if (freeNode > cap) // 容量内容纳不下所有的剩余节点
    {
        isOk = false;
        return {-1, -1};
    }

    if (fruit[cur]) // 这个点是果实，判断能否恰好把剩下的节点分配完
    {
        if (freeNode < cap)
            return {freeNode, 1};
        else
            return {0, 0};
    }
    else // 这个点不是果实，尝试改变子树最小的子果实的分配方式
    {
        if (freeNode + minChild < cap)
            return {freeNode + minChild, 1};
        else if (freeNode + minChild == cap)
            return {0, 0};
        else if (freeNode < cap)
            return {freeNode, 0};
        else
        {
            isOk = false;
            return {-1, -1};
        }
    }
}
inline void solve()
{
    root = ff[0];
    dfsConvert(root, 0);
    // 二分答案
    int l = 1, r = n, ans = 0;
    int mid = (l + r) >> 1;
    while (l <= r)
    {
        mid = (l + r) >> 1;
        bool isOk = true;
        dfsCheck(root, mid, isOk);
        if (isOk)
        {
            ans = mid;
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    printf("%d\n", ans);
}
```

## `stack` - 丹钓战

### Subtask 1：暴力（15%）

朴素模拟，题目怎么说就怎么做。

### Subtask 2：$n \leq 5000$（15%）

考虑离线做法，把所有询问按 $l$ 分组储存。对于所有 $l$ 相同的询问只需模拟一次就能得出全部的答案。

### Subtask 3：$b_i=n-i+1$（10%）

$b$ 数组变成了单调递减，那么只需考虑 $a$ 能否影响出栈。只有相同的 $a$ 才能互相影响出栈，因此答案就是 $l$ 所处的 $a$ 相同的连续段的后半截长度。

### Subtask 4：$a=i$（15%）

~~其实已经和正解差不了多少了...~~

### Subtask 5：AC（100%）

先把所有的二元组都拿来模拟一遍，在模拟的过程中记录一个元素是被谁弹出栈的，即下一个能够把自己弹出栈的元素是谁。由于成功的二元组一定会在入栈前把栈里的元素都清空，因此不需要管两个成功的二元组之间的空隙，这样回答询问时可以进行跳跃，加快模拟。

如果是暴力跳的话已经可以拿到 60 分了。再加上倍增优化即可 AC。

```c++
struct Node
{
    Node(pii p, int _i) : a(p.first), b(p.second), idx(_i)
    {
    }
    int a, b, idx;
};
stack<Node> S;
int nxt[MAX_LOG][MAXN];
inline void solve()
{
    for (int i = 1; i <= n; i++)
        nxt[0][i] = n + 1;
    // 预处理模拟
    for (int i = 1; i <= n; i++)
    {
        while (!S.empty() && (S.top().a == P[i].first || S.top().b <= P[i].second))
            nxt[0][S.top().idx] = i, S.pop();
        S.push(Node(P[i], i));
    }
    // 计算倍增
    for (int lg = 1; lg < MAX_LOG; lg++)
    {
        for (int i = 1; i <= n; i++)
        {
            nxt[lg][i] = nxt[lg - 1][nxt[lg - 1][i]];
        }
    }
    while (q--)
    {
        int l, r;
        l = read(), r = read();
        int ans = 1, cur = l;
        for (int lg = MAX_LOG - 1; lg >= 0; lg--)
        {
            if (nxt[lg][cur] != 0 && nxt[lg][cur] <= r)
                ans += (1 << lg), cur = nxt[lg][cur];
        }
        printf("%d\n", ans);
    }
}
```

## `discuss` - 讨论

## `sort` - 如何正确地排序

### Subtask 1：暴力（10%）

算它就完了！

### Subtask 2：$m=2$（10%）

$min$ 和 $max$ 一定是两行中的其中之一且不相等，那把所有的 $min$ 和 $max$ 加起来就相当于把矩阵里的所有数加起来。还要乘个倍数 $2n$。

### Subtask 3：$m=3$（30%）
