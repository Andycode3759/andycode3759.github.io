---
title: 考试总结 - 2023.9.8 周练
date: 2023-09-09 16:55:28 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## Problem T1

### Subtask 1：暴力（0%）

枚举所有红蓝边的匹配排列，然后累加每种状态的连通块数量并统计总方案数，相除即为结果。统计方案数可以用并查集（$O(n!nlogn)$）或 DFS Floodfill（$O(n!n)$），按理来说后者会稍微快一点，但是无所谓，反正开了捆绑测试后 $X=Y=5$ 一卡，一分都拿不到。

```c++
int x, y, n;

int red[MAXN], blue[MAXN], tot, sum;
bool vis[MAXN];

void dfsFlood(int cur)
{
    if (vis[cur])
        return;
    vis[cur] = true;
    if (cur <= n)
        dfsFlood(cur + n);
    else
        dfsFlood(cur - n);
    for (int i = 1; i <= n; i++)
    {
        if (red[i] == cur)
            dfsFlood(blue[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        if (blue[i] == cur)
            dfsFlood(red[i]);
    }
}
inline int getCnt()
{
    for (int i = 1; i <= 2 * n; i++)
        vis[i] = false;
    int res = 0;
    for (int i = 1; i <= 2 * n; i++)
    {
        if (!vis[i])
            dfsFlood(i), res++;
    }
    return res;
}
inline void solve1()
{
    int rc = 0, bc = 0;
    for (int i = 1; i <= x; i++)
        red[++rc] = i;
    for (int i = n + 1; i <= 2 * n - x; i++)
        red[++rc] = i;
    for (int i = x + 1; i <= n; i++)
        blue[++bc] = i;
    for (int i = 2 * n - x + 1; i <= 2 * n; i++)
        blue[++bc] = i;
    sort(blue + 1, blue + 1 + n);
    do
    {
        tot++;
        sum += getCnt();
    } while (next_permutation(blue + 1, blue + 1 + n));
    printf("%.9lf\n", 1.0 * sum / tot);
}
```

### Subtask 2：$X=0$（+20%）

**注意到**答案即为 $\sum_{i=1}^{Y}{1 \over i}$。

### Subtask 3：AC（100%）

**注意到**答案即为 $\sum_{i=1}^{X}{1 \over {2i-1} }+\sum_{i=1}^{Y}{1 \over {2X+i} }$。

总之就是极其难蚌的一道数学题，暴力分一分都不给属实过分（鬼知道出题人有什么方法可以 $O(1)$ 维护直接求出连通块数量）。能够 AC 无非两条路径：第一为依靠极其强大的数学功底推导得出结论，第二为观察数据大胆猜测结论（事实证明几乎所有 AC 的人都是通过后者）。非常适合选拔数学竞赛人才~~或者出题人的 npy~~。

## Problem T2

### Subtask 1：暴力，$n \leq 20$（30%）

二进制枚举每个位置的状态，$1$ 留 $0$ 不留，拼接后维护最大值作为答案即可。

```c++
char strS[MAXN], strT[MAXN];
char tmp[MAXN * 2], ans[MAXN * 2];
int n;

inline void solve1()
{
    for (int S = 0; S < (1 << n); S++)
    {
        int tot = 0;
        for (int i = 0; i < n; i++)
        {
            if ((S & (1 << i)) != 0)
                tmp[tot++] = strS[i];
        }
        for (int i = 0; i < n; i++)
        {
            if ((S & (1 << i)) != 0)
                tmp[tot++] = strT[i];
        }
        tmp[tot] = '\0';
        if (strcmp(tmp, ans) > 0)
        {
            strcpy(ans, tmp);
        }
    }
    printf("%s\n", ans);
}
```

### Subtask 2：$S=T$（+20%）

直接把最大的那个字母全部拿出来即可。

### Subtask 3：AC（100%）

可以用二进制表示状态、有大小关系、求数量最大的最优解，这些特性和 01 背包十分相似。可以把每个位置看成是一个重量为 $1$ 的物品，价值的大小关系则取决于字符串拼接后的字典序；定义 $dp(i,j)$ 为前 $i$ 个位置中选 $j$ 个留下的答案字符串（$i,j$ 即分别对应物品阶段和背包容量），这样就能转化为 01 背包问题了。甚至和原版 01 背包一样可以滚掉一维。

```c++
char strS[MAXN], strT[MAXN];
int n;
string dp[MAXN];
inline void solve3()
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = i; j >= 1; j--)
        {
            // 先根据上一次的答案构造出这一次选择“留下”的答案，相当于计算两个价值的“和”
            string lst = dp[j - 1], cur;
            for (int i = 0; i < lst.size() / 2; i++)
                cur.push_back(lst[i]);
            cur.push_back(strS[i]);
            for (int i = lst.size() / 2; i < lst.size(); i++)
                cur.push_back(lst[i]);
            cur.push_back(strT[i]);
            // 和原版01背包的唯一不同点就在这里，剩下的都一模一样

            dp[j] = max(dp[j], cur);
        }
    }
    string ans = "";
    for (int i = 1; i <= n; i++)
        ans = max(ans, dp[i]);
    printf("%s\n", ans.c_str());
}
```

由此可见，知识的迁移能力非常重要。一道题不可能把“正解就是 01 背包”的信息直接写在题面上，应该根据问题的特点观察出它和某个经典模型的相同特性，再灵活变式来解决问题。

...但这就是唯一的出路了吗？

### Subtask 3.1：模拟退火（100%）

每次随机选择一个位置并修改其状态（留下->离开，或离开->留下），然后就可以套用模拟退火模板了。两个状态间的差值估价可以直接用 `strcmp` 函数，关键就在于调参~~和运气~~。

```c++
const double MAX_TEMP = 100000;
const double SPEED = 0.9995;

char strS[MAXN], strT[MAXN];
int n;

bool keep[MAXN], ans[MAXN], bak[MAXN];

inline int stateCmp()
{
    string a, b;
    for (int i = 1; i <= n; i++)
    {
        if (keep[i])
            a.push_back(strS[i]);
        if (ans[i])
            b.push_back(strS[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        if (keep[i])
            a.push_back(strT[i]);
        if (ans[i])
            b.push_back(strT[i]);
    }
    return strcmp(a.c_str(), b.c_str());
}

inline void simAnneal()
{
    for (int i = 1; i <= n; i++)
        keep[i] = rand() % 2 == 1;

    double Temp = MAX_TEMP;
    while (Temp >= 1e-5)
    {
        int t = rand() % n + 1;
        keep[t] = !keep[t];
        int delta = stateCmp();
        if (delta > 0)
        {
            for (int i = 1; i <= n; i++)
                ans[i] = keep[i];
        }
        else
        {
            if (1.0 * rand() / RAND_MAX < exp(-abs(delta) / Temp))
                keep[t] = !keep[t];
        }
        Temp *= SPEED;
    }
}

int main()
{
    srand(time(0));

    scanf("%s", strS + 1);
    scanf("%s", strT + 1);
    n = strlen(strS + 1);

    while ((1.0 * clock()) / CLOCKS_PER_SEC <= 0.95)
        simAnneal();

    string a;
    for (int i = 1; i <= n; i++)
    {
        if (ans[i])
            a.push_back(strS[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        if (ans[i])
            a.push_back(strT[i]);
    }
    printf("%s\n", a.c_str());

    return 0;
}
```

## Problem T3

### Subtask 1：暴力，$N \leq 10$（0%）

直接 DFS，每一步枚举要删掉的数，到达边界时数一下 $S$ 里的连续数字段并维护最大值。本来尝试用 STL 里的 `list` 和 `map`，但后来发现不如直接数组模拟来的简洁。

```c++
int n;
int arr[MAXN];
bool del[MAXN], inS[MAXN];
int ans = 0;
void dfs(int step)
{
    int d = 1;
    for (int cnt = 0; cnt <= n - step; d++)
    {
        if (!del[d])
            cnt++;
    }
    while (del[d])
        d++;
    del[d] = true;
    inS[arr[d]] = true;

    if (step > n)
    {
        int lst = -1, combo = 0;
        for (int i = 1; i <= 2 * n + 1; i++)
        {
            if (!inS[i])
                continue;
            if (lst == -1 || i == lst + 1)
            {
                combo++;
                ans = max(ans, combo);
            }
            else
                combo = 0;
            lst = i;
        }
        inS[arr[d]] = false;
        del[d] = false;
        return;
    }

    for (int i = 1; i <= 2 * n + 1; i++)
    {
        if (del[i])
            continue;
        del[i] = true;
        dfs(step + 1);
        del[i] = false;
    }

    inS[arr[d]] = false;
    del[d] = false;
}
```

每一步的决策数量为 $O(N)$，总决策步数为 $N$，数连续数字段需要 $O(N)$ ~~（已经可以忽略不计了）~~，时间复杂度为 $O(N^N)$。跟 T1 同理，$N=10$ 一卡，一分没有。

### Subtask 2：初始序列递增（+5%）

手玩一下就可以发现规律，每一次都删掉最左边的数，答案即为 $N+1$。

### Subtask 3：AC（100%）

## Problem T4

### Subtask 1：暴力，$1 \leq N,M \leq 4$（10%）

枚举种菜方案，对于每一个方案输出到终点的总方案数和路过菜的数量为 1 的方案数，累加答案。要写 3 个 DFS。时间复杂度 $O(玄学)$ ~~（不会算）~~。

```c++
int n, m;
bool bad[MAXN][MAXN];

bool plant[MAXN][MAXN];
int tot = 0, ans = 0;
int dfsWalk(int x, int y, int p)
{
    if (plant[x][y])
        p++;
    int res = 0;
    if (x == n - 1 && y == m - 1)
        return (p == 1) ? 1 : 0;
    if (p > 1)
        return 0;
    if (x < n - 1 && !bad[x + 1][y])
        res += dfsWalk(x + 1, y, p);
    if (y < m - 1 && !bad[x][y + 1])
        res += dfsWalk(x, y + 1, p);
    return res;
}
void dfsTot(int x, int y)
{
    if (x == n - 1 && y == m - 1)
    {
        tot++;
        return;
    }
    if (x < n - 1 && !bad[x + 1][y])
        dfsTot(x + 1, y);
    if (y < m - 1 && !bad[x][y + 1])
        dfsTot(x, y + 1);
}
void dfsState(int x, int y)
{
    if (x == n)
        y++, x = 0;

    if (y == m)
    {
        if (dfsWalk(0, 0, 0) == tot)
        {
            ans++;
        }
        return;
    }
    plant[x][y] = false;
    dfsState(x + 1, y);
    if (!bad[x][y])
    {
        plant[x][y] = true;
        dfsState(x + 1, y);
    }
}

inline void solve1()
{
    dfsTot(0, 0);
    dfsState(0, 0);
    printf("%d\n", ans);
}
```

### Subtask 2：没有损坏格（+40%）

不难发现合法的种菜方案一定是一条把整个地图切成两半的对角线，答案为 $N+M+1$。

### 隐藏 Subtask：无法到达终点（+10%）

对于种菜方案没有限制。记没有损坏的格子数为 $Q$，答案即为 $2^Q$。

### Subtask 3：AC（100%）
