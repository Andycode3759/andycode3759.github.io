---
title: 考试总结 - 2023.9.13（Public Judge Round#2 Div.1）
date: 2023-09-14 17:32:02 +0800
categories: [考试总结]
tags: [pjudge]
math: true
---

## A - 恰钱

### Subtask 1：$l \leq l \leq r \leq 10^7$（30%）

如果打纯暴力，那么时间复杂度最坏就是 $O(nq) \sim 10^{12}$ 的，显然不行。考虑把 $[1,10^7]$ 内的所有好数全都枚举求出来丢到一个 `vector` 里，查询时只要 `lower_bound` + `upper_bound` 就可以了，时间骤降到 $O(n+qlogn) \sim 1.23 \times 10^7$。

### Subtask 2：$l,r$ 随机（+30%）

**做题经验：区间端点随机往往意味着区间长度很小。** 这种情况下纯暴力不太可能达到最坏时间复杂度，所以纯暴力直接搞就行。

### Subtask 3：AC（100%）

框架和 Subtask 1 是一样的，预处理所有好数+二分查找。但显然不能再枚举了，分析一下发现好数都满足以下形态：

- 低位有连续 $i$ 个 $0$；
- 第 $i+1$ 位是 $1$；
- 高位是 $0$ 和 $1$ 穿插，包含 $i-1$ 个 $1$。

于是乎就可以枚举 $i$，再用 DFS 构造出所有的好数。不用担心高位没有上界，判断数字本身大于 $10^9$ 时即可返回。

```c++
vector<int> goodnum;

void dfsGenerate(int step, int lst, int cnt, int t)
{
    if (step >= cnt)
    {
        goodnum.push_back(t);
        return;
    }
    for (int i = lst + 1; (t | (1 << i)) <= MAXN; i++)
    {
        dfsGenerate(step + 1, i, cnt, t | (1 << i));
    }
}

int main()
{
    goodnum.push_back(2);

    for (int i = 2; i <= 15; i++)
        dfsGenerate(1, i, i, 1 << i);

    sort(goodnum.begin(), goodnum.end());

    int q = fastRead();
    for (int i = 1; i <= q; i++)
    {
        int l = fastRead(), r = fastRead();
        int idxL = lower_bound(goodnum.begin(), goodnum.end(), l) - goodnum.begin();
        int idxR = upper_bound(goodnum.begin(), goodnum.end(), r) - goodnum.begin();
        if (idxL == idxR)
            printf("-1\n");
        else
            printf("%d\n", goodnum[idxL]);
    }
    return 0;
}
```

### 赛时想法

询问数很多，考虑离线做。所有询问区间按 $l$ 排序，$l$ 相同按 $r$ 排序，再枚举 $[1,10^9]$ 的所有数，如果是好数就更新对应区间的答案。用类似于扫描线的思想维护当前数所能对应的一段区间 $[cl,cr]$。

```c++
int q, l, r;
struct Query
{
    int l, r, id;
    bool operator<(const Query &b) const
    {
        if (l != b.l)
            return l < b.l;
        return r < b.r;
    }
};
Query Q[MAXN];
int ans[MAXN];

int main()
{
    q = fastRead();
    int maxR = -1;
    for (int i = 1; i <= q; i++)
    {
        Q[i].l = fastRead();
        Q[i].r = fastRead();
        maxR = max(maxR, Q[i].r);
        Q[i].id = i;
        ans[i] = -1;
    }

    sort(Q + 1, Q + 1 + q);
    Q[q + 1].l = Q[q + 1].r = MAXN + MAXN;
    int cl = 1, cr = 1;
    for (int i = Q[1].l; i <= Q[q].r; i++)
    {
        if (cl > q)
            break;
        while (Q[cl].r < i)
            cl++;
        while (Q[cr + 1].l <= i && cr < q)
            cr++;

        if (ctz(i) == ppc(i))
        {
            for (int j = cl; j <= cr; j++)
                ans[Q[j].id] = i;
            cl = ++cr;
        }
    }

    for (int i = 1; i <= q; i++)
        printf("%d\n", ans[i]);
}
```

但对拍后发现这种做法是错误的，因为所有区间排序后右端点 $r$ 不一定单调，而且也无法保证所有区间分布构成一个凸包，导致少数几个询问的答案出错。解决方法是检查一遍所有的答案，对于错误的答案暴力修正。

```c++
inline void fixAns(int x)
{
    ans[Q[x].id] = -1;
    for (int i = Q[x].l; i <= Q[x].r; i++)
    {
        if (ctz(i) == ppc(i))
        {
            ans[Q[x].id] = i;
            break;
        }
    }
}

for (int i = 1; i <= q; i++)
{
    if (ans[Q[i].id] == -1 || ans[Q[i].id] < Q[i].l || ans[Q[i].id] > Q[i].r)
    {
        fixAns(i);
    }
}
```

其实这个做法从第一步“枚举 $[1,10^9]$ 的所有数”开始就已经注定了拿不到分。如果当时能冷静分析清楚问题，及时从错误的想法中跳出来，说不定就能往预处理的方向想。同时切 Subtask 的策略也不合理，Subtask 1 用纯暴力是没有分的，对于应该暴力的 Subtask 2 却划给了超时的离线做法，哪怕不切 Subtask 全开暴力按理也应该能拿到 30 分。

```c++
inline void solve1(); // 暴力
inline void solve2(); // 离线

if (maxR <= 10000000)
    solve1();
else
    solve2();
```

## B - 排序

### Subtask 1：特殊性质 A（10%）

给出的排列是把一个有序序列切成若干段、每一段翻转后得到的结果。手玩一下应该能发现，最优策略就是把每一段的开头入栈（一定是单调递增的）、剩下的数全都忽略。至于写程序，只要维护当前最大值把数列扫一遍，数一下最大值更新了几次即可。

```c++
int cnt = 1, mx = arr[1];
for (int i = 2; i <= n; i++)
{
    if (arr[i] > mx)
    {
        cnt++;
        mx = arr[i];
    }
}

printf("%d\n", cnt);
```

有时候骗分不应该总考虑怎么把某个特殊性质判断出来切分，尤其是某道题只会一个 Subtask 的时候。直接忽略掉其他 Subtask，这 10 分是稳拿的；如果还想考虑判断性质、加点什么别的 Subtask 做法，那可能就会导致这 10 分都拿不到。

## C - 图同构

## D - 找零

### Subtask 1：01 背包（20%）

由于只关心 1 元钱的个数，所以买东西时一定不能用 1 元钱，而剩下的面额纸币无论怎么搭配都无所谓。之后容易推出，单个购买物品一定比打包购买更优，因为买东西的目的就是要把 5 元及以上的纸币打散（即 $a\ mod\ 5+b\ mod\ 5$ 一定比 $(a+b)\ mod\ 5$ 更优）。这样一个物品对答案的贡献就是 $ (5 - a \ mod\ 5)\ mod\ 5$，把价格看作物品体积，就能转化为 01 背包问题了。

```c++
int vol = (x / 5) * 5;
for (int i = 1; i <= n; i++)
{
    for (int j = vol; j >= arr[i]; j--)
    {
        dp[j] = max(dp[j], dp[j - arr[i]] + (5 - arr[i] % 5) % 5);
    }
}
printf("%d\n", dp[vol] + x % 5);
```

如果总是拘泥于把所有纸币的数量看成一个状态，还考虑物品打包购买等等，那必定会寄。
