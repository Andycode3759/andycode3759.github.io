---
title: 考试总结 - 2023.10.28
date: 2023-10-29 21:33:18 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## $T_1$

一眼广搜扩展状态，暴搜就完事了。但是出题人卡了 BFS，必须要 DFS，匪夷所思。

```c++
unordered_set<ll> S;
void dfs(ll c)
{
    if (c == 0)
        return;
    for (ll i : x)
    {
        if (S.count(c / i))
            continue;
        S.insert(c / i);
        dfs(c / i);
    }
}
inline void solve_DFS()
{
    dfs(n);
    S.insert(0);
    S.insert(n);
    printf("%d\n", S.size());
}

queue<ll> Q;
inline void solve_BFS()
{
    Q.push(n);
    while (!Q.empty())
    {
        ll k = Q.front();
        Q.pop();
        if (S.count(k))
            continue;
        S.insert(k);
        for (ll c : x)
        {
            for (ll i = k / c; i > 0; i /= c)
                if (!S.count(i))
                    Q.push(i);
        }
    }
    S.insert(0);
    printf("%d\n", S.size());
}
```

## $T_2$

### Subtask 1：20%

二进制枚举子集算 $\gcd$，然后以 $\gcd$ 为下标记录答案。

### Subtask 2：60%

首先，设 $p_x$ 为 $n$ 个数中有多少个数是 $x$ 的倍数。可以证明，如果一个 $k$ 存在方案的话，那么答案的最大值就是 $p_k$，现在只要考虑怎么求最小值就行了。

注意到值域 $3 \times 10^5$ 并不是很大，考虑 $O(值域)$ 的 DP。设 $dp(x)$ 表示 $\gcd$ 为 $x$ 时的最小答案，初值为 $dp(S_i)=1$，其余空间为 $\inf$。从大到小枚举 $x$，并枚举 $S_i$ 转移，有 $dp(\gcd(x,S_i))=\min \{dp(x)+1\}$（本来 $\gcd=x$ 的情况，搭上 $S_i$ 后变成 $\gcd(x,S_i)$，同时多了一个数）。如果对于某个 $k$，$dp(k)$ 没被更新到，答案自然是 $-1$，其余情况直接输出 $dp(k),p_k$ 即可。

```c++
int ansMn[MAXN], ansMx[MAXN];
inline void solve2()
{
    for (int x = 1; x <= m; x++)
    {
        for (int i = 1; i <= n; i++)
        {
            if (arr[i] % x == 0)
                ansMx[x]++;
        }
    }

    for (int i = 1; i < MAXN; i++)
        ansMn[i] = INF;
    for (int i = 1; i <= n; i++)
        ansMn[arr[i]] = 1;
    for (int x = MAXN - 1; x >= 1; x--)
    {
        if (ansMn[x] >= INF)
            continue;
        for (int i = 1; i <= n; i++)
        {
            ansMn[__gcd(x, arr[i])] = min(ansMn[__gcd(x, arr[i])], ansMn[x] + 1);
        }
    }
    for (int i = 1; i <= m; i++)
    {
        if (ansMn[i] >= INF)
        {
            printf("-1 -1\n");
        }
        else
        {
            printf("%d %d\n", ansMn[i], ansMx[i]);
        }
    }
}
```

### Subtask 3：100%

继续考虑优化。方便起见记值域为 $w$。首先求 $p$ 可以不用 $O(nw)$ 枚举，改成枚举因子，时间降至 $O(n \sqrt w)$；接着注意到，前 $7$ 个质数的乘积 $2 \times 3 \times 5 \times 7 \times 11 \times 13 \times 17 \approx 5 \times 10^5$，与 $w$ 同阶，说明答案的值域一定在 $[1,7]$ 以内（最坏的情况就是刚好来一个前 $7$ 个质数乘积作为 $k$，最多要 $7$ 个数才能凑出 $\gcd$）。考虑枚举答案 $t$ 并检验是否可行。

已经知道 $p_x$ 的情况下，如果从这 $p_x$ 个数中随便选 $t$ 个出来，那么它们的 $\gcd$ 也一定是 $x$ 的倍数。但是我们的目的是恰好凑出 $\gcd = x$，所以对于高倍的情况需要排除。设 $dp(i,x)$ 表示从满足条件的 $p_x$ 个数中选 $i$ 个，它们的 $\gcd$ 恰好等于 $x$ 的方案数，那么就有 $dp(i,x)=C_{p_x}^{i} - \sum_{\forall j, j \times x < w}dp(i,j \times x)$。从大到小枚举 $x$ 转移就可以求出所有的 $dp(i,x)$。

求答案也是很简单的，对于一个 $k$，找到一个最小的 $t \in [1,7]$ 满足 $dp(t,k)>0$ 即可，找不到就是无解。

一些细节：算组合数可以取模逆元（因为方案数一定是非负的），也可以开 `__int128` 直接算，如果采用后者就要用 $O(m)$ 的组合数 $C_{n}^{m}$ 算法（从 $n$ 开始递减，连乘 $m$ 个数，再除掉 $m!$）。因为保证了 $t \in [1,7]$，所以算起来还是很快的。

```c++
using ll = __int128;

inline ll C(int x, int y)
{
    ll res = 1;
    for (int i = 0; i < y; i++)
        res *= (x - i);
    for (int i = 2; i <= y; i++)
        res /= i;
    return res;
}

int ansMx[MAXN];
ll dp[8][MAXN];
inline void solve2()
{
    for (int i = 1; i <= n; i++)
    {
        for (int x = 1; x * x <= arr[i]; x++)
        {
            if (arr[i] % x != 0)
                continue;
            ansMx[x]++, ansMx[arr[i] / x]++;
            if (x * x == arr[i])
                ansMx[x]--;
        }
    }

    for (int t = 1; t <= 7; t++)
    {
        for (int x = MAXN - 1; x >= 1; x--)
        {
            if (ansMx[x] == 0)
                continue;
            dp[t][x] = C(ansMx[x], t);
            for (int j = 2; j * x < MAXN; j++)
            {
                dp[t][x] -= dp[t][j * x];
            }
        }
    }

    for (int k = 1; k <= m; k++)
    {
        bool flag = false;
        for (int mn = 1; mn <= 7; mn++)
        {
            if (dp[mn][k] > 0)
            {
                printf("%d %d\n", mn, ansMx[k]);
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            printf("-1 -1\n");
        }
    }
}
```

考试时在草稿纸上无意中画出了 $p_x$ 的表格，也注意到了有些答案的最大值就等于 $p_x$，但是没有继续往 DP 的方向想。

## $T_3$

### Subtask 1：20%

首先可以转化题目条件：定义两个城市 $(x_1,y_1),(x_2,y_2)$ 之间的距离为 $d=\max \{\lvert x_1-x_2 \rvert,\lvert y_1-y_2 \rvert\}$，如果两个城市的距离大于 $k$，说明它们不能被一个正方形框住，也就是说它们一定不属于同一个国家。

可以把这一关系转化为无向图存起来，再 $O(m^n)$ 枚举状态检验计数。

### Subtask 2：40%

基于上面建图的结论，可以考虑 $m=2$ 的做法。此时 $n$ 个国家的关系就抽象成了可能不连通的若干个简单无向图，那么答案就等价于给这些图的每个点染上黑白二色、使得有边相连的两个点颜色不同的方案数。

因为只有两种颜色，只要检验一个独立连通图可否染色就可以了（能染就产生 $\times 2$ 的贡献，不能的话答案直接为 $0$），可以用 BFS Floodfill，检测到已染色的点和即将要染的颜色一致就说明有冲突。

```c++
struct Point
{
    int x, y;
};
inline int maxDis(Point a, Point b)
{
    return max(abs(a.x - b.x), abs(a.y - b.y));
}

int n, m, k;
Point city[MAXN];
vector<int> G[MAXN];

int vis[MAXN];
inline int check(int s)
{
    if (G[s].size() == 0)
    {
        vis[s] = 1;
        return 2;
    }
    queue<pair<int, int>> Q;
    Q.push({s, 1});
    while (!Q.empty())
    {
        int u = Q.front().first, x = Q.front().second;
        Q.pop();
        if (vis[u] != 0)
            continue;
        vis[u] = x;
        for (int v : G[u])
        {
            if (vis[v] == x)
                return 0;
            Q.push({v, x == 1 ? 2 : 1});
        }
    }
    return 2;
}
inline void main()
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = i + 1; j <= n; j++)
        {
            if (maxDis(city[i], city[j]) > k)
                G[i].push_back(j), G[j].push_back(i);
        }
    }
    int ans = 1;
    for (int i = 1; i <= n; i++)
    {
        if (vis[i] == 0)
            ans = ans * check(i) % MOD;
        if (ans == 0)
            break;
    }
    printf("%d\n", ans);
}
```

### Subtask 3：100%

接下来就是攻克 $m=3$ 的难关。尝试推广上面的染色方案做法是不可行的，因为 3-Color 问题是著名的 NP-Complete Problem，即甚至没有已知的多项式复杂度算法能够构造一个解（证明[见此](https://www.geeksforgeeks.org/3-coloring-is-np-complete/)，[中文搬运](https://www.cnblogs.com/YjmStr/p/17274926.html)），更别说数方案数了。解决本题需要换一个切入点。

## $T_4$
