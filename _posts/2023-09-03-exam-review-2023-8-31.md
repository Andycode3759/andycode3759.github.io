---
title: 考试总结 - 2023.8.31
date: 2023-09-03 17:19:40 +0800
categories: [考试总结]
tags: [内部模拟赛]
math: true
---

## `tree` - 奇迹之夜

### Subtask 1：暴力（30%）

首先可以预处理一下 $m$ 和 $w$（在代码里记作 `val1` 和 `val2`），让 $w$ 取上两者最大值。

DFS 有很多种枚举状态的方式，其中有一种既比较方便迭代也很方便求答案，就是枚举每个点是否作为后勤基地。

```c++
bool mark[MAXN];
long long ans = 0;
inline long long calc()
{
    long long res = 0;
    for (int i = 1; i <= n; i++)
    {
        if (mark[i])
            continue;

        if (dep[i] <= L + 1)
            res += val2[i];
        else
        {
            bool flag = false;
            for (int e = head[i]; e != 0; e = G[e].next)
            {
                int v = G[e].dest;
                if (mark[v])
                {
                    flag = true;
                    break;
                }
            }
            if (flag)
                res += val2[i];
            else
                res += val1[i];
        }
    }
    return res;
}
void dfs(int step)
{
    if (step > n)
    {
        ans = max(ans, calc());
        return;
    }
    mark[step] = false;
    dfs(step + 1);
    mark[step] = true;
    dfs(step + 1);
}
```

这样写暴力，既简洁又优美，而且不容易被邻界数据卡掉，考试时还能为突破正解节约宝贵时间。

赛时写的暴力比这种方法复杂许多，每个点枚举了三种状态（普通/聚会/后勤），还要检查状态合法性。算法设计就像做数学题选择解题方法，方法选的好可以过程简洁、事半功倍，方法没选好就会大大增加运算量（表现为代码复杂度或者时间复杂度），难调试还容易丢分。因此考场上要想节约时间，学会把代码写简洁非常重要。

### Subtask 2：AC（100%）

### 相关题目

技能点：树形 DP。

- [UVA1218 Perfect Service 完美的服务](https://www.luogu.com.cn/problem/UVA1218)
- [NOIP2022 T3 建造军营](https://www.luogu.com.cn/problem/P8867)

## `plant` - 树莓立方体

### Subtask 1：暴力（10%）

直接模拟计算即可。写 ST 表纯属浪费表情。

对于大部分类似的有关区间最值的数据结构题，ST 表对于暴力的优化效果都是微乎其微的（典例包括 NOIP2022 T4）。

### Subtask 2：暴力优化（35%）

由于 $n$ 比较小，可以花 $O(n^2)$ 的时间把所有 $x,y$ 对应的答案都预处理出来，再以 $x$ 或 $y$ 为基准端点做前缀和。回答询问时可以 $O(n)$ 加回去，或者二次预处理出所有 $l,r$ 对应的答案（相当于二维前缀和）。

```c++
int memF[MAXN][MAXN];
long long sumL[MAXN][MAXN];

for (int x = 1; x <= n; x++)
{
    int mm[22];
    int mx = -1;
    for (int i = 1; i <= k; i++)
        mm[i] = val[i][x];
    for (int y = x; y <= n; y++)
    {
        mx = -1;
        for (int i = 1; i <= k; i++)
        {
            mm[i] = min(mm[i], val[i][y]);
            mx = max(mx, mm[i]);
        }
        memF[x][y] = F(mx);
    }
}

for (int x = 1; x <= n; x++)
{
    for (int y = x; y <= n; y++)
    {
        sumL[x][y] = sumL[x][y - 1] + memF[x][y];
    }
}

while (q--)
{
    scanf("%d %d", &l, &r);
    long long ans = 0;
    for (int i = l; i <= r; i++)
        ans += sumL[i][r] - sumL[i][l - 1];
    printf("%lld\n", ans);
}
```

### Subtask 3：$k=1$（+25%）

### Subtask 4：$a \leq 2$（+15%）

### 相关题目

技能点：数据结构，二维前缀和。

- [NOIP2022 T1 种花](https://www.luogu.com.cn/problem/P8865)
- [NOIP2022 T4 比赛](https://www.luogu.com.cn/problem/P8868)

## `division` - 爱上火车

### Subtask 1：暴力（5%）

枚举每一天的决策，即坐或不坐火车。时间 $O(2^n)$。

### Subtask 2：简单 DP（25%）

有决策的地方就有 DP。考虑最简单的 $O(n^2)$ DP，记 $dp(i,j)$ 为第 $i$ 天坐 $j$ 次火车的最佳答案，每一天可以选择坐或不坐火车：$dp(i,j)=a((j-1)\ mod\ k,i)+max\{dp(i-1,j),dp(i-1,j-1)\}$。注意当坐了 $j$ 次火车时，当前所在的城市就是 $(j-1)\ mod\ k$。此外初始化也要注意，$dp(1,1)=a(0,1)$（即第一天的状态），其余的初值为无穷大而不是 $0$（因为不可能从非法的状态转移过来）。

```c++
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= n; j++)
    {
        dp[i][j] = -INF;
    }
}
dp[1][1] = val[0][1];
for (int i = 2; i <= n; i++)
{
    for (int j = 1; j <= n; j++)
    {
        dp[i][j] = val[(j - 1) % k][i] + max(dp[i - 1][j], dp[i - 1][j - 1]);
    }
}
```

每次询问时回答 $dp(n,m)$ 即可。
