---
title: 题解 - 洛谷P8293 [省选联考 2022] 序列变换
date: 2024-01-29 20:28:30 +0800
categories: [题解]
tags: [洛谷, 省选]
math: true
---

> 大致思路和[Alex_Wei 大佬的这篇题解](https://www.luogu.com.cn/blog/AlexWei/solution-p8293)基本一致，这里就不浪费过审题解名额了。

## 题目大意

给定一个合法括号序列，每个左括号有一个与其绑定的权值，可以进行如下操作：

1. 交换逆序的括号对 `)( -> ()` ，代价为“右括号匹配的那个左括号”的权值 $\times x$ 加上左括号的权值 $\times y$；
2. 交换相邻的两组合法子括号序列 `(()()) -> (()())`（注意权值会随之转移），无代价。

求消除所有逆序括号对（即结果会形如 `((((...))))`）所需的最小代价。

## 分析

注意到操作 2 代价为 $0$，也就是说在同一层里并列的括号序列之间的顺序是无关紧要的。这也就暗示，如果我们把一个合法括号序列看成一颗树（被一对括号包在里面的括号序列是这对括号的儿子），那么一个节点的所有儿子之间的顺序是无关紧要的。

![](https://cdn.luogu.com.cn/upload/image_hosting/vg4vij13.png)

把括号序列转化为树，可以用栈很轻松地实现。

```c++
vector<int> G[MAXN];
stack<int> S;
S.push(0);  // 以0为根
for (int i = 1; i <= 2 * n; i++)
{
    if (str[i] == '(')  // 左括号表示新节点，并且开始获取这个节点的儿子
        S.push(++tot);
    else if (str[i] == ')') // 右括号表示节点列表的结束，把栈顶节点作为栈顶下面节点的儿子
    {
        int t = S.top();
        S.pop();
        G[S.top()].push_back(t);
    }
}
```

考虑操作 1 在树上的意义。手玩一下可以发现，记参与交换的两个括号分别来自第 $i,j$ 个括号对，那么操作 1 就相当于在树上把 $j$ 的所有儿子都变成 $i$ 的儿子，再把 $j$ 自己也变成 $i$ 的儿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/jafw8bur.png)

这样，我们就得到了一个与树有关的等价问题：

> 给定一颗以 $0$ 号节点为根的树，可以在树上任选两个有共同父亲的节点 $i,j$，将 $j$ 本身及 $j$ 的所有子树都变成 $i$ 的儿子，代价为 $xv_i+yv_j$。求把树变成一条链所需的最小代价。

我们可以按照 $x,y$ 的取值来进行分类讨论：首先，当 $x=y=0$ 时，答案显然为 $0$。

## Subtask 1：$x=0,y=1$（16%）

**只有儿子节点的代价才会被计算。** 重新分析操作 1 的过程，发现它本质上是让 $j$ 的深度 $+1$。我们可以按照深度从小到大来一层层地处理树：在同一深度的节点只选一个留下来作为链上节点，其他的都通过操作 1 转移到深度 $+1$ 的地方，这样处理完 $n-1$ 层就得到了链。这样操作还能为更深的节点留下最多的选择余地。

那么该选谁做链上节点呢？因为现在只计算转移的节点的代价，不难想到贪心：同一层里留下权值最大的那个节点。

代码实现方面，可以用 `multiset` 来维护当前层所有节点的权值，同时另外用一个变量 `sum` 来维护这些权值的总和（一个个暴力加会超时）。

```c++
namespace Solve1 // x=0,y=1
{
    multiset<int, greater<int>> V;  // *V.begin()是最大权值，*V.rbegin()是最小权值
    vector<int> dn[MAXN];
    inline void main()
    {
        ll ans = 0;
        for (int i = 1; i <= n; i++)
            dn[dep[i]].push_back(i);
        ll sum = 0;
        for (int d = 1; d <= n; d++)
        {
            for (int t : dn[d])
                V.insert(val[t]), sum += val[t];
            sum -= *V.begin();
            ans += sum;
            V.erase(V.begin());
        }
        printf("%lld\n", ans);
    }
}
```

## Subtask 1.1：所有 $v_i$ 相等（8%）

无论选哪个节点，产生的代价都一样，只要计算节点总共会被转移多少次就好了。

```c++
namespace SolveSP // val are equal
{
    int cnt[MAXN];
    inline void main()
    {
        for (int i = 1; i <= n; i++)
            cnt[dep[i]]++;
        ll mult = 0;
        for (int i = 1; i <= n; i++)
        {
            mult += cnt[i] - 1;
            cnt[i + 1] += cnt[i] - 1;
        }
        mult *= x + y;
        printf("%lld\n", mult * val[1]);
    }
}
```

## Subtask 2：$x=1,y=1$（16%）

**儿子节点和链上节点都会计算代价。** 其实这个情况是比 $x=1,y=0$ 要更简单的。我们还是考虑一层留一个节点，但是该留谁呢？我们先任选一个点 $h$，然后考虑放其他点的策略：

- 如果 $h$ **是**这一层里权值最小的节点，那么最优策略毫无疑问是把剩下的节点全部直接挂上去，代价为 $sum + v_h \times (cnt-2)$（$sum$ 是当前层所有权值和，$cnt$ 是当前层节点个数，下同）；
- 如果 $h$ **不是**这一层里权值最小的节点，那么我们就找到权值最小的那个节点 $m$，把除了 $h$ 以外的节点都挂在 $m$ 上，产生 $sum-v_h-v_m+v_m \times (cnt-2)$ 的代价；最后把 $m$ 挂在 $h$ 上（因为这样可以顺便把其他所有节点都一次性挂在 $h$ 上），产生 $v_h + v_m$ 的代价，总代价也是 $sum + v_m \times (cnt-2)$。

我们发现无论放点的策略如何，代价只和当前层的权值最小的节点有关。那么为了让每一层的“权值最小节点”的权值都尽量小，我们在处理一层时就要“淘汰”掉当前权值最大的那个节点，也就是说选权值最大的那个节点留在链上。

代码实现和 Subtask 1 很像，只要改一下算答案的式子就行。

```c++
namespace Solve2    // x=1,y=1
{
    inline void main()
    {
        ll ans = 0;
        for (int i = 1; i <= n; i++)
            dn[dep[i]].push_back(i);
        ll sum = 0;
        for (int d = 1; d <= n; d++)
        {
            for (int t : dn[d])
                V.insert(val[t]), sum += val[t];
            ans += sum + *V.rbegin() * (V.size() - 2);
            sum -= *V.begin();
            V.erase(V.begin());
        }
        printf("%lld\n", ans);
    }
}
```

## Subtask 3：$x=1,y=0$（60%）

**只计算链上节点的代价。** 假设我们在一层内已经确定留下节点 $h$，那么挂点的策略和 Subtask 2 是一样的。记权值最小的节点为 $m$，总代价就是 $v_h + v_m \times (cnt-2)$。

看起来似乎只要最小化 $v_h$，也就是说在一层里留下权值最小的节点就行了。但是实际情况并没有那么简单，因为我们没有考虑往下挂的节点对下一层决策的影响，即局部贪心不能得到全局最优。比如说，我们可以把某个节点一直往下挂到深度为 $n$ 的地方，使得它的权值不产生任何贡献。

我们从全局入手，记 $cnt_i$ 为第 $i$ 层的节点数，$m_i$ 为第 $i$ 层的最小权值，$h_i$ 为第 $i$ 层的留在链上的节点，那么总代价为

$$
\sum_{i=1}^{n} (v_{h_i} + v_{m_i} \times (cnt_i-2))
$$

当 $i=n$ 时，显然有 $cnt_n = 1, h_n=m_n$，所以第 $n$ 层的代价为 $v_{h_n} + v_{h_n} \times (1-2)=0$。所以总代价还可以减掉一层：

$$
\sum_{i=1}^{n-1} (v_{h_i} + v_{m_i} \times (cnt_i-2))
$$

展开：

$$
\sum_{i=1}^{n-1} v_{h_i} + \sum_{i=1}^{n-1} v_{m_i} \times (cnt_i-2)
$$

把左边那一项化简可得：

$$
\sum_{i=1}^{n} v_i - v_{h_n} + \sum_{i=1}^{n-1} v_{m_i} \times (cnt_i-2)
$$

$cnt$ 数组与我们挂点的策略无关，只与树的初始形态有关。也就是说，我们要最大化 $v_{h_n}$ 的同时，最小化每一层的 $v_{m_i}$。我们可以考虑**把每一层的最大权值节点和最小权值节点都往下挂**，这样就能达到目的了。

- 当 $cnt_i=1$ 时显然不用操作；
- 当 $cnt_i>2$ 时就按照上面的分析，随便选一个既非最小也非最大权值的节点留下来；
- 最棘手的情况反而是 $cnt_i=2$，因为留小还是留大必须选一个。依然从全局入手，我们发现 $cnt$ 数组预处理出来后一定是单峰的，它会形似 $1,1,\dots,2,2,\dots,\geq 3,\dots,3,2,1$（$1$ 段和 $2$ 段可能不存在）。也就是说一开始的一串 $1$ 可以忽略，后面的 $\geq 3$ 的部分按上面说的处理，最后那个 $2$ 显然是把权值大的往下挂。关键在于前面这串 $2$，它表示在靠近根的地方有一条链多一个节点。显然我们可以从这些节点里任选一个往下挂，放进后面 $\geq 3$ 的这串里。但问题是选谁呢？我们说这串 $2$ 中每一层的决策都是**留小还是留大必须选一个**，但实际上会发现，最优策略只可能是下放这串 $2$ 中所有节点的权值最小或最大者，而中间的那些节点一定不优。为什么？放权值最小的节点有利于后面 $\geq 3$ 串的决策，放权值最大的节点可以让最后落单的那个节点省得最多，而放一个权值既非最小又非最大的节点则两头都沾不到好处。

综上所述，我们只要预处理出 $cnt$，找到开头的那段连续的 $2$，找出这段区间对应的节点，然后分别按照**放最小权值**和**放最大权值**模拟一遍，取更优解即可。

接下来就是代码实现。我们不需要真的处理出 $2$ 段的具体节点有哪些，只需要处理出这一段节点按深度的前缀最大/最小权值即可。可以把 $2$ 段之前/之后的前缀最值分成两段（因为后面的模拟还要用它来计算答案），放进同一个数组里。具体细节可以参考注释。

```c++
namespace Solve3 // x=1,y=0
{
    vector<int> dn[MAXN];
    int cnt[MAXN];
    int mn[MAXN], mx[MAXN];
    inline void main()
    {
        for (int i = 1; i <= n; i++)
            dn[dep[i]].push_back(i);
        cnt[0] = 1;
        for (int i = 1; i <= n; i++)
            cnt[i] = cnt[i - 1] + dn[i].size() - 1;
        for (int i = 1; i <= n; i++)
            mn[i] = (1 << 30) - 1;
        int p = 1, q = 1;   // [p,q) => cnt=2段
        while (p <= n && cnt[p] == 1)
            p++, q++;
        while (q <= n && cnt[q] == 2)
            q++;
        ll sum = 0;
        for (int i = p; i <= n - 1; i++)    // 直接从p开始，忽略前面的一串1对应的节点
        {
            if (i != q) // 在2段的结尾处要重新计算前缀最小/最大权值
                mn[i] = mn[i - 1], mx[i] = mx[i - 1];
            for (int t : dn[i])
            {
                mn[i] = min(mn[i], val[t]); // 计算前缀最小/最大权值
                mx[i] = max(mx[i], val[t]);
                sum += val[t];  // 累加一般节点对答案的贡献
            }
        }
        // 放最小，落单的是>=3段的最大权值
        ll ans1 = sum - mx[n - 1];
        // 放最大，落单的是全局最大权值
        ll ans2 = sum - max(mx[q - 1], mx[n - 1]);
        // 从>=3段开始模拟
        for (int i = q; i <= n - 1; i++)
        {
            // 2段放了最小，这一层的贡献由全局最小决定
            ans1 += ((ll)cnt[i] - 2) * min(mn[q - 1], mn[i]);
            // 2段放了最大，这一层的贡献由>=3段内的最小决定
            ans2 += ((ll)cnt[i] - 2) * mn[i];
        }
        printf("%lld\n", min(ans1, ans2));
    }
}
```
