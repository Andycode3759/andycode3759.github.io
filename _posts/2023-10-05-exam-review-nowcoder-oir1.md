---
title: 考试总结 - 牛客OI赛前集训营 提高组 R1
date: 2023-10-05 17:26:35 +0800
categories: [考试总结]
tags: [牛客]
math: true
---

## `A` - 情景剧

本来在考试时是无意中写出正解了的，但是因为对拍过程中出了问题导致以为答案错误，于是没有把正解写进去，只拿了暴力分。至于具体发生了什么：

- 拿到题目第一件事就是写 $n \leq 1000$ 的暴力，因为空间是 $O(n^2)$ 的，所以数组没有开太大，只开到了 $1003 \times 1003$：

  ```c++
  int minVal[1003][1003], maxVal[1003][1003];
  inline void solve1() {...}
  ```

- 回过头来想正解时尝试了一种“似乎不太正确”的做法（具体是什么...代码已经被删掉了 qwq），对拍时惊喜地发现过了。此时数据生成器里最大的 $n$ 只开到了 $1000$。
- 再看题目分析数据范围时怀疑解法正确性和 $n$ 的规模有关，于是在数据生成器里把 $n$ 开到 $2000$ 重新对拍，但此时**并没有去修改暴力程序把空间扩大**。再加上编译时没有加 `-fsanitize=undefined`，导致数组越界没有被查出来，以为这个解法真的不适用于过大的 $n$，然后就悲剧了。

简单说一下官方正解：对数组建小根笛卡尔树，求出每个节点的子树在数组上覆盖的范围，用 ST 表预处理区间最大值，然后在笛卡尔树上枚举每个树根求答案取最大值即可。

## `B` - 抽卡

### Subtask 1：暴力枚举（15%）

我会 DFS！注意可以把所有的奇数和偶数分别简并在一起，就不需要用到 `set` 全排列之类乱七八糟的东西了。

### Subtask 2：暴力 DP（30%）

把奇数视作 $1$，偶数视作 $0$，定义 $dp(i,a,b,x)$ 为一共放了 $a$ 个 $1$ 和 $b$ 个 $0$ 且第 $i$ 个放了 $x$ 的最优答案。枚举 $i,a,b$ 进行暴力转移，复杂度 $O(n^3q)$。

```c++
// 这里就不需要维护可用的0和1的数量了，只需要总数
int cnt0, cnt1;
int dp[2][103][103][103];
inline int calc2()
{
    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            for (int k = 0; k <= n; k++)
            {
                dp[0][i][j][k] = dp[1][i][j][k] = INF;
            }
        }
    }
    if (val[1] == 0 || !fixed[1])
        dp[0][1][1][0] = 0;
    if (val[1] == 1 || !fixed[1])
        dp[1][1][0][1] = 0;
    for (int i = 2; i <= n; i++)
    {
        for (int j = 0; j <= cnt0; j++)
        {
            for (int k = 0; k <= cnt1; k++)
            {
                if (j > 0 && (val[i] == 0 || !fixed[i]))
                {
                    dp[0][i][j][k] = min(dp[0][i - 1][j - 1][k], dp[1][i - 1][j - 1][k] + 1);
                }
                if (k > 0 && (val[i] == 1 || !fixed[i]))
                {
                    dp[1][i][j][k] = min(dp[0][i - 1][j][k - 1] + 1, dp[1][i - 1][j][k - 1]);
                }
            }
        }
    }
    return min(dp[0][n][cnt0][cnt1], dp[1][n][cnt0][cnt1]);
}
```

### Subtask 3：贪心（60%）

分析一下发现，一段可修改的区间能产生多少代价，取决于区间两端固定的是什么。如果两端相同，那么这段区间的代价要么为 $0$ 要么为 $2$；如果两端不同，那么无论怎么放都会产生 $1$ 的代价。可以考虑在消耗尽量少的情况下优先满足代价为 $2$ 的区间，再把剩下的答案算出来累加。

## `C` - 修改 01 序列

真正的签到题。不难发现修改后的序列要满足这种形式：$\texttt{...?000?000?000?}$，其中问号既可以是 $0$ 也可以是 $1$。这样就可以枚举序列最开头多余的 $0$ 的数量，数出不符合形式的位置有多少个，求个最小值就是答案。至于怎么数，可以反着做，先求出一共有多少个 $1$，然后把问号位置上的 $1$ 减去就是需要修改的 $1$ 的数量。复杂度 $O(n)$。

```c++
inline void solve3()
{
    int cnt = 0;
    int ans = INF;
    for (int i = 1; i <= n; i++)
        cnt += arr[i];
    for (int j = 1; j <= d; j++)
    {
        int sum = 0;
        for (int i = j; i <= n; i += d)
        {
            if (arr[i] == 1)
                sum++;
        }
        ans = min(ans, cnt - sum);
    }
    printf("%d\n", ans);
}
```
