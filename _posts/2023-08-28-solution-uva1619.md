---
title: 题解 - UVA1619 Feel Good 感觉不错
date: 2023-08-28 22:19:13 +0800
categories: [题解]
tags: [uva]
math: true
---

> 注：洛谷上本题已经关闭题解通道，故只能发在个人博客里。没打算申请加入主题解区。
>
> 如果你觉得原题数据太坑影响做题体验，可以提交在这道[带 SPJ 的镜像题](https://www.luogu.com.cn/problem/U333722)中。

首先考虑整个区间 $[1,n]$，得到的答案是所有数的和乘以所有数的最小值。很明显这个最小值会拖整体答案的后腿，我们要尝试令区间和损失尽量小的情况下增大区间内的最小值。

可以找到整个区间内最小值所在的位置 $p$，把位置 $p$ 挖掉，整个区间就断成了两块 $[1,p-1]$ 和 $[p+1,n]$。这样两个区间内各自的最小值就有可能增大了（当然，在最小值出现多次时可能还是不变）。

基于这个想法，就可以写出一套简洁的分治算法：对于目前考虑的区间 $[l,r]$，先计算并尝试更新答案，再把最小值的位置 $p$ 扣掉，递归处理 $[l,p-1]$ 和 $[p+1,r]$。

区间求和可以用前缀和预处理，查询区间内最小值所在位置可以用 ST 表预处理。主算法时间为 $O(logn)$，ST 表预处理为 $O(nlogn)$。

**Talk is Cheap, Show me the Code:**

```c++
// 本代码没有针对原题的若干坑点做特殊处理，故直接提交不能AC。
// 但是可以AC带SPJ实现的镜像题。
#include <algorithm>
#include <cstdio>
using namespace std;
const int MAXN = 100005;
const int MAX_LOG = 18;

int lg2[MAXN];

int n;
int arr[MAXN];
long long sum[MAXN];
int stPos[MAX_LOG][MAXN];

// ST表查询
inline int stQuery(int l, int r)
{
    int lg = lg2[r - l + 1];
    int p1 = stPos[lg][l], p2 = stPos[lg][r - (1 << lg) + 1];
    if (arr[p1] < arr[p2])
        return p1;
    else
        return p2;
}

long long ans = 0;
int al = 1, ar = 1;

// 分治主算法
void updateAns(int l, int r)
{
    if (r < l)
        return;
    int p = stQuery(l, r);
    long long cur = (sum[r] - sum[l - 1]) * arr[p];
    if (cur > ans)
    {
        ans = cur;
        al = l, ar = r;
    }
    updateAns(l, p - 1);
    updateAns(p + 1, r);
}

int main()
{
    lg2[1] = 0;
    for (int i = 2; i < MAXN; i++)
        lg2[i] = lg2[i >> 1] + 1;

    while (scanf("%d", &n) == 1 && n != 0)
    {
        ans = -1;
        for (int i = 1; i <= n; i++)
        {
            scanf("%d", arr + i);
            sum[i] = sum[i - 1] + arr[i];
            stPos[0][i] = i;
        }

        // ST表预处理
        for (int lg = 1; lg < MAX_LOG; lg++)
        {
            for (int i = 1; i + (1 << (lg - 1)) <= n; i++)
            {
                int p1 = stPos[lg - 1][i], p2 = stPos[lg - 1][i + (1 << (lg - 1))];
                if (arr[p1] < arr[p2])
                    stPos[lg][i] = p1;
                else
                    stPos[lg][i] = p2;
            }
        }

        updateAns(1, n);
        printf("%lld\n%d %d\n\n", ans, al, ar);
    }

    return 0;
}
```
