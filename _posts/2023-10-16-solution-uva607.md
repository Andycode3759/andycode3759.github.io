---
title: 题解 - UVA607 Scheduling Lectures 课程安排
date: 2023-10-16 19:45:38 +0800
categories: [题解]
tags: [uva]
math: true
---

首先，最少课程数量是可以直接贪心求出来的，重点在于如何求出最小的不满意度。

设通过贪心求出最少课程数量为 $cnt$，定义 $dp(i,j)$ 表示在第 $i$ 个知识点结束第 $j$ 节课时的最小不满意度，答案为 $dp(n,cnt)$。转移时枚举第 $j-1$ 节课是在什么时候结束的（设为 $k$），求出 $[k+1,i]$ 段知识点的时间总和就是目前第 $j$ 节课的时长（记为 $len$），那么状态转移方程就是：

$$
dp(i,j)= \min_{0 \leq k < i,len \leq l}\{dp(k,j-1)+\operatorname{DI}(L-len)\}
$$

其中 $\operatorname{DI}$ 就是题面中给出的计算不满意度的函数，边界是 $dp(0,0)=0$，其他位置初值为无穷大。

一些细节：

- 求 $len$ 可以预处理前缀和，但是因为我懒，就在转移时从后往前枚举维护 $len$ 了；
- 注意不能拖堂，$len>L$ 的情况是不能被考虑的；
- 总不满意度可能比较大，要开 `long long`；
- 注意 UVA 的严格换行符检查，输出结尾不能出现两个空行。

Show the code:

```c++
#include <algorithm>
#include <cstdio>
using namespace std;
using ll = long long;
const int MAXN = 1003;
const ll INF = (1LL << 60) - 1;

int n, l, c;
int arr[MAXN];

ll dp[MAXN][MAXN]; // 第j节课以知识点i结尾

inline ll DI(int t)
{
    if (t == 0)
        return 0;
    else if (1 <= t && t <= 10)
        return -c;
    else
        return (ll)(t - 10) * (t - 10);
}

inline void solve(int Kase)
{
    int cnt = 0, sum = 0;
    for (int i = 1; i <= n; i++)
    {
        if (sum + arr[i] > l)
            sum = arr[i], cnt++;
        else
            sum += arr[i];
    }
    cnt++;
    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            dp[i][j] = INF;
        }
    }
    dp[0][0] = 0;
    for (int i = 1; i <= n; i++)
    {
        int len = 0;
        for (int k = i - 1; k >= 0; k--)
        {
            len += arr[k + 1];
            if (len > l)
                break;
            for (int j = 1; j <= cnt; j++)
            {
                // 第k+1个知识点到第i个知识点作为一堂课
                dp[i][j] = min(dp[i][j], dp[k][j - 1] + DI(l - len));
            }
        }
    }
    printf("Case %d:\n", Kase);
    printf("Minimum number of lectures: %d\n", cnt);
    printf("Total dissatisfaction index: %lld\n", dp[n][cnt]);
}

int main()
{
    int Kase = 1;
    while (scanf("%d", &n) == 1)
    {
        if (n == 0)
            break;
        if (Kase > 1)
            printf("\n");
        scanf("%d %d", &l, &c);
        for (int i = 1; i <= n; i++)
            scanf("%d", arr + i);
        solve(Kase++);
    }
    return 0;
}
```

时间复杂度：$cnt$ 最坏情况下可能与 $n$ 同阶，所以时间最坏情况下可能有 $O(n^3)$。但由于在枚举 $k$ 的时候对 $len$ 加了取值优化，因此在 $t_i$ 普遍很大、$cnt$ 很大时，$k$ 的枚举次数很小；反之在 $t_i$ 普遍很小、$cnt$ 很小时，$k$ 的枚举次数会接近 $n$。二者互相制约导致总时间几乎不可能跑满 $O(n^3)$，因此可以放心通过本题。
