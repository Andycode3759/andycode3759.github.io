---
title: 题解 - 洛谷P2547 [AHOI2004] DNA变异
date: 2023-08-15 20:57:48 +0800
categories: [题解]
tags: [洛谷]
math: true
---

大力出奇迹！既然 $n$ 只有 $8000$，那么 $O(n^2)$ 左右数量级的做法是完全没有问题的，最外层的框架只需两层循环枚举：

```c++
for (int i = 1; i <= n; i++)
{
    for(int j = i + 1; j <= n; j++)
    {
        if(check(i, j))
            ans++;
    }
}
```

所以只需要实现这个 `check` 函数就可以了。首先显然的一点是，两个 DNA 串中各个字母的数量必须相等。这个可以通过简单的计数+哈希实现：

```c++
inline int hsash(int idx)
{
    int cnt[6] = {0};
    for (int i = 1; i <= 8; i++)
    {
        switch (input[i])
        {
        case 'A':
            cnt[1]++;
            break;
        case 'T':
            cnt[2]++;
            break;
        case 'C':
            cnt[3]++;
            break;
        case 'G':
            cnt[4]++;
            break;
        }
    }
    return cnt[1] * 1000 + cnt[2] * 100 + cnt[3] * 10 + cnt[4];
    // 之后只需判断两个字符串的哈希是否相等即可
}
```

然后，对于两个字母数量相同的字符串，题目已经排除了两者完全一致的情况。我们可以将字符串的 $8$ 个位置分为两类：**变化位**（发生过交换的位置）和**非变化位**（没有发生过交换的位置），两类各 $4$ 个位置。

很明显，两个字符串上所有非变化位的字符需要数量和位置完全相同。那么变化位呢？需要注意的是，变化位上的四个字符可不是乱变的。考虑一个只有四个元素的排列 $[1,2,3,4]$，在纸上手玩一下，可以发现只有三种变化方式是符合题意的：

- $[2,1,4,3]$（交换 $1,2$ 和 $3,4$ 号位）
- $[3,4,1,2]$（交换 $1,3$ 和 $2,4$ 号位）
- $[4,3,2,1]$（交换 $1,4$ 和 $2,3$ 号位）

既然这样，我们可以枚举四个变化位的位置和变化方式，对于每一种组合再依次分别检查变化位和非变化位是否符合上述条件。代码并不需要很优美，使出全部的力气暴力循环即可 AC（请重点参考 `check` 函数的实现）：

```c++
#include <cstdio>
// 既然用不到STL，要啥万能头？
const int MAXN = 8008;

// 四元序列所有可能的变化情况
const int Change[][4] = { {3, 4, 1, 2},
                          {2, 1, 4, 3},
                          {4, 3, 2, 1} };

int n;
int hashs[MAXN];
int dna[MAXN][10];
char input[10];

// 将输入的字符串转化为数字，再顺便算个哈希
inline void storeInput(int idx)
{
    int cnt[6] = {0};
    for (int i = 1; i <= 8; i++)
    {
        switch (input[i])
        {
        case 'A':
            cnt[1]++;
            dna[idx][i] = 1;
            break;
        case 'T':
            cnt[2]++;
            dna[idx][i] = 2;
            break;
        case 'C':
            cnt[3]++;
            dna[idx][i] = 3;
            break;
        case 'G':
            cnt[4]++;
            dna[idx][i] = 4;
            break;
        default:
            break;
        }
    }
    hashs[idx] = cnt[1] * 1000 + cnt[2] * 100 + cnt[3] * 10 + cnt[4];
}

// 检查两串DNA是否符合条件（参数是下标）
inline bool check(int d1, int d2)
{
    // 第一步：检查哈希
    if (hashs[d1] != hashs[d2])
        return false;

    // 第二步：枚举变化位和变化情况
    int ma[5];
    for (ma[1] = 1; ma[1] <= 5; ma[1]++)
        for (ma[2] = ma[1] + 1; ma[2] <= 6; ma[2]++)
            for (ma[3] = ma[2] + 1; ma[3] <= 7; ma[3]++)
                for (ma[4] = ma[3] + 1; ma[4] <= 8; ma[4]++)
                    for (int c = 0; c < 3; c++)
                    {
                        bool good = true;
                        // 第三步：检查变化位，按照变化情况，查看对应位置上的字符是否相同
                        for (int i = 0; i < 4; i++)
                        {
                            int target = ma[Change[c][i]];
                            if (dna[d1][ma[i + 1]] != dna[d2][target])
                            {
                                good = false;
                                break;
                            }
                        }
                        if (!good)
                            continue;
                        // 第四步（不要漏了！）：检查非变化位是否完全相同
                        for (int i = 1; i <= 8; i++)
                        {
                            if (i == ma[1] || i == ma[2] || i == ma[3] || i == ma[4])
                                continue;
                            if (dna[d1][i] != dna[d2][i])
                            {
                                good = false;
                                break;
                            }
                        }
                        if (!good)
                            continue;

                        // 过了全部四关，就是合格的搭配啦 ^_^
                        return true;
                    }

    return false;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", input + 1);
        storeInput(i);
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = i + 1; j <= n; j++)
        {
            if (check(i, j))
                ans++;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

时间复杂度：不会算，外层框架是 $O(n^2)$ 的，`check` 函数应该比较接近于常数级别。

综上，本题没有太高的思维难度，比较适合拿来练习码力。~~（说实话标蓝题是不是有些虚高了？建议降成绿题）~~
